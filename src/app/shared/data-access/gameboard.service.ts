import { inject, Injectable, Signal } from '@angular/core';
import {
  ChaosSpaceEventModel,
  ChaosSpaceEventTemplateModel,
  ChaosSpaceEventType,
  GameboardSpaceModel,
  OmitAutoGeneratedColumns,
  PlayerModel,
  SpecialSpaceEventModel,
  SpecialSpaceEventsForCurrentRoundModel,
  SpecialSpaceEventTemplateModel,
  SpecialSpaceEventType,
} from '../util/supabase-types';
import {
  PostgrestResponse,
  PostgrestSingleResponse,
  SupabaseClient,
} from '@supabase/supabase-js';
import {
  Function,
  GameboardSpaceEffect,
  realtimeUpdatesFromTable,
  SpaceEventStatus,
  Table,
  View,
} from '../util/supabase-helpers';
import { GameboardSpaceEntryFormModel } from '../../gm-tools/feature/gameboard-space-entry-page.component';
import { Database, Json } from '../util/schema';
import {
  combineLatest,
  map,
  Observable,
  of,
  shareReplay,
  switchMap,
} from 'rxjs';
import { whenNotNull } from '../util/rxjs-helpers';
import { toSignal } from '@angular/core/rxjs-interop';
import { GameStateService } from './game-state.service';
import { PlayerService } from './player.service';

@Injectable({
  providedIn: 'root',
})
export class GameboardService {
  private readonly supabase: SupabaseClient<Database> = inject(SupabaseClient);
  private readonly gameStateService = inject(GameStateService);
  private readonly playerService = inject(PlayerService);

  readonly gameboardSpaces$: Observable<GameboardSpaceModel[] | null> =
    this.gameStateService.sessionId$.pipe(
      whenNotNull((activeSessionId) =>
        (
          realtimeUpdatesFromTable(
            this.supabase,
            Table.GameboardSpace,
            `session_id=eq.${activeSessionId}`,
          ) as Observable<GameboardSpaceModel[]>
        ).pipe(map((spaces) => spaces.sort((a, b) => a.id - b.id))),
      ),
      shareReplay(1),
    );

  readonly specialSpaceEventTemplates$: Observable<
    SpecialSpaceEventTemplateModel[] | null
  > = this.gameStateService.sessionId$.pipe(
    whenNotNull(
      (activeSessionId) =>
        realtimeUpdatesFromTable(
          this.supabase,
          Table.SpecialSpaceEventTemplate,
          `session_id=eq.${activeSessionId}`,
        ) as unknown as Observable<SpecialSpaceEventTemplateModel[]>,
    ),
    shareReplay(1),
  );

  readonly gameboardSpaces: Signal<GameboardSpaceModel[] | null | undefined> =
    toSignal(this.gameboardSpaces$);

  readonly specialSpaceEvents$: Observable<SpecialSpaceEventModel[]> =
    this.gameStateService.sessionId$.pipe(
      switchMap(
        (sessionId) =>
          realtimeUpdatesFromTable(
            this.supabase,
            Table.SpecialSpaceEvent,
            `session_id=eq.${sessionId}`,
          ) as Observable<SpecialSpaceEventModel[]>,
      ),
      switchMap((specialSpaceEvents) => {
        if (!specialSpaceEvents?.length) return of([]);

        return combineLatest({
          players: this.playerService.players$,
          specialSpaceEventTemplates: this.specialSpaceEventTemplates$,
        }).pipe(
          map(({ players, specialSpaceEventTemplates }) =>
            specialSpaceEvents
              .sort((a, b) => a.id - b.id)
              .map((specialSpaceEvent) => {
                const player = players?.find(
                  (p) => p.player_id === specialSpaceEvent.player_id,
                );

                const specialSpaceEventTemplate =
                  specialSpaceEventTemplates?.find(
                    (template) => template.id === specialSpaceEvent.template_id,
                  );

                return {
                  ...specialSpaceEvent,
                  player: player ?? null,
                  template: specialSpaceEventTemplate ?? null,
                };
              }),
          ),
        );
      }),
      shareReplay({ bufferSize: 1, refCount: true }),
    );

  readonly specialSpaceEventsForThisTurn$: Observable<
    SpecialSpaceEventModel[] | null
  > = this.gameStateService.roundNumber$.pipe(
    switchMap((roundNumber) =>
      this.specialSpaceEvents$.pipe(
        map(
          (events) =>
            events?.filter((event) => event.round_number === roundNumber) ??
            null,
        ),
      ),
    ),
    shareReplay(1),
  );

  readonly allSpecialSpaceEventsForThisTurnAreResolved$: Observable<boolean> =
    this.specialSpaceEventsForThisTurn$.pipe(
      map(allSpaceEventsAreResolved),
      shareReplay(1),
    );

  readonly nonCanceledSpecialSpaceEventsForThisTurn$: Observable<
    SpecialSpaceEventModel[] | null
  > = this.specialSpaceEventsForThisTurn$.pipe(
    map(
      (specialSpaceEvents) =>
        specialSpaceEvents?.filter(
          (event) => event.status !== SpaceEventStatus.Canceled,
        ) ?? null,
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly chaosSpaceEventTemplates$: Observable<
    ChaosSpaceEventTemplateModel[] | null
  > = this.gameStateService.sessionId$.pipe(
    whenNotNull(
      (activeSessionId) =>
        realtimeUpdatesFromTable(
          this.supabase,
          Table.ChaosSpaceEventTemplate,
          `session_id=eq.${activeSessionId}`,
        ) as unknown as Observable<ChaosSpaceEventTemplateModel[]>,
    ),
    shareReplay(1),
  );

  readonly chaosSpaceEvents$: Observable<ChaosSpaceEventModel[]> =
    this.gameStateService.sessionId$.pipe(
      switchMap(
        (sessionId) =>
          realtimeUpdatesFromTable(
            this.supabase,
            Table.ChaosSpaceEvent,
            `session_id=eq.${sessionId}`,
          ) as Observable<ChaosSpaceEventModel[]>,
      ),
      switchMap((chaosSpaceEvents) => {
        if (!chaosSpaceEvents?.length) return of([]);

        return combineLatest({
          players: this.playerService.players$,
          chaosSpaceEventTemplates: this.chaosSpaceEventTemplates$,
        }).pipe(
          map(({ players, chaosSpaceEventTemplates }) =>
            chaosSpaceEvents
              .sort((a, b) => a.id - b.id)
              .map((chaosSpaceEvent) => {
                const player = players?.find(
                  (p) => p.player_id === chaosSpaceEvent.player_id,
                );

                const chaosSpaceEventTemplate = chaosSpaceEventTemplates?.find(
                  (template) => template.id === chaosSpaceEvent.template_id,
                );

                return {
                  ...chaosSpaceEvent,
                  player: player ?? null,
                  template: chaosSpaceEventTemplate ?? null,
                };
              }),
          ),
        );
      }),
      shareReplay({ bufferSize: 1, refCount: true }),
    );

  readonly chaosSpaceEventsForThisTurn$: Observable<
    ChaosSpaceEventModel[] | null
  > = this.gameStateService.roundNumber$.pipe(
    switchMap((roundNumber) =>
      this.chaosSpaceEvents$.pipe(
        map(
          (events) =>
            events?.filter((event) => event.round_number === roundNumber) ??
            null,
        ),
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly allChaosSpaceEventsForThisTurnAreResolved$: Observable<boolean> =
    this.chaosSpaceEventsForThisTurn$.pipe(
      map(allSpaceEventsAreResolved),
      shareReplay({ bufferSize: 1, refCount: true }),
    );

  readonly nonCanceledChaosSpaceEventsForThisTurn$: Observable<
    ChaosSpaceEventModel[] | null
  > = this.chaosSpaceEventsForThisTurn$.pipe(
    map(
      (chaosSpaceEvents) =>
        chaosSpaceEvents?.filter(
          (event) => event.status !== SpaceEventStatus.Canceled,
        ) ?? null,
    ),
    shareReplay(1),
  );

  async createNewGameboardSpaceType<T extends GameboardSpaceEffect>(
    gameboardSpace: OmitAutoGeneratedColumns<GameboardSpaceModel<T>>,
  ): Promise<PostgrestSingleResponse<null>> {
    return (
      this.supabase
        .from(Table.GameboardSpace)
        // @ts-expect-error: for whatever reason, this doesn't accept the effect_data type as JSON
        .insert([gameboardSpace])
    );
  }

  async updateGameboardSpaceType<T extends GameboardSpaceEffect>(
    gameboardSpaceId: number,
    partialGameboardSpace: Partial<
      OmitAutoGeneratedColumns<GameboardSpaceModel<T>>
    >,
  ): Promise<PostgrestSingleResponse<null>> {
    return (
      this.supabase
        .from(Table.GameboardSpace)
        // @ts-expect-error: for whatever reason, this doesn't accept the effect_data type as JSON
        .update(partialGameboardSpace)
        .eq('id', gameboardSpaceId)
    );
  }

  async deleteGameboardSpaceType(
    gameboardSpaceId: number,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.DeleteGameboardSpace, {
      gameboard_space_id: gameboardSpaceId,
    });
  }

  async createNewSpecialSpaceEventTemplate<T extends SpecialSpaceEventType>(
    eventTemplate: OmitAutoGeneratedColumns<SpecialSpaceEventTemplateModel<T>>,
  ): Promise<PostgrestSingleResponse<null>> {
    return (
      this.supabase
        .from(Table.SpecialSpaceEventTemplate)
        // @ts-expect-error: for whatever reason, this doesn't accept the effect_data type as JSON
        .insert([eventTemplate])
    );
  }

  async updateSpecialSpaceEventTemplate<T extends SpecialSpaceEventType>(
    gameboardSpaceId: number,
    partialSpecialSpaceEventTemplate: Partial<
      OmitAutoGeneratedColumns<SpecialSpaceEventTemplateModel<T>>
    >,
  ): Promise<PostgrestSingleResponse<null>> {
    return (
      this.supabase
        .from(Table.SpecialSpaceEventTemplate)
        // @ts-expect-error: for whatever reason, this doesn't accept the effect_data type as JSON
        .update(partialSpecialSpaceEventTemplate)
        .eq('id', gameboardSpaceId)
    );
  }

  async deleteSpecialSpaceEventTemplate(
    specialSpaceEventTemplateId: number,
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase
      .from(Table.SpecialSpaceEventTemplate)
      .delete()
      .eq('id', specialSpaceEventTemplateId);
  }

  async createNewChaosSpaceEventTemplate<T extends ChaosSpaceEventType>(
    eventTemplate: OmitAutoGeneratedColumns<ChaosSpaceEventTemplateModel<T>>,
  ): Promise<PostgrestSingleResponse<null>> {
    return (
      this.supabase
        .from(Table.ChaosSpaceEventTemplate)
        // @ts-expect-error: for whatever reason, this doesn't accept the effect_data type as JSON
        .insert([eventTemplate])
    );
  }

  async updateChaosSpaceEventTemplate<T extends ChaosSpaceEventType>(
    gameboardSpaceId: number,
    partialChaosSpaceEventTemplate: Partial<
      OmitAutoGeneratedColumns<ChaosSpaceEventTemplateModel<T>>
    >,
  ): Promise<PostgrestSingleResponse<null>> {
    return (
      this.supabase
        .from(Table.ChaosSpaceEventTemplate)
        // @ts-expect-error: for whatever reason, this doesn't accept the effect_data type as JSON
        .update(partialChaosSpaceEventTemplate)
        .eq('id', gameboardSpaceId)
    );
  }

  async deleteChaosSpaceEventTemplate(
    chaosSpaceEventTemplateId: number,
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase
      .from(Table.ChaosSpaceEventTemplate)
      .delete()
      .eq('id', chaosSpaceEventTemplateId);
  }

  async logRoundMoves(
    roundNumber: number,
    playerSpaceChanges: GameboardSpaceEntryFormModel,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.LogRoundMoves, {
      roundnumber: roundNumber,
      playermoves: playerSpaceChanges as unknown as Json,
    });
  }

  async getSpecialSpaceEventsForCurrentRound(): Promise<
    PostgrestResponse<SpecialSpaceEventsForCurrentRoundModel>
  > {
    return this.supabase.from(View.SpecialSpaceEventsForCurrentRound).select();
  }

  async selectSpecialSpaceEventTemplate(
    specialSpaceEventId: SpecialSpaceEventModel['id'],
    specialSpaceEventTemplateId: SpecialSpaceEventTemplateModel['id'],
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase
      .from(Table.SpecialSpaceEvent)
      .update({
        template_id: specialSpaceEventTemplateId,
        status: SpaceEventStatus.WaitingToBegin,
      })
      .eq('id', specialSpaceEventId);
  }

  async startSpecialSpaceEvent(
    specialSpaceEventId: SpecialSpaceEventModel['id'],
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase
      .from(Table.SpecialSpaceEvent)
      .update({
        status: SpaceEventStatus.InProgress,
      })
      .eq('id', specialSpaceEventId);
  }

  async cancelSpecialSpaceEvent(
    specialSpaceEventId: SpecialSpaceEventModel['id'],
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase
      .from(Table.SpecialSpaceEvent)
      .update({
        status: SpaceEventStatus.Canceled,
      })
      .eq('id', specialSpaceEventId);
  }

  async selectChaosSpaceEventTemplate(
    chaosSpaceEventId: ChaosSpaceEventModel['id'],
    chaosSpaceEventTemplateId: ChaosSpaceEventTemplateModel['id'],
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase
      .from(Table.ChaosSpaceEvent)
      .update({
        template_id: chaosSpaceEventTemplateId,
        status: SpaceEventStatus.WaitingToBegin,
      })
      .eq('id', chaosSpaceEventId);
  }

  async startChaosSpaceEvent(
    chaosSpaceEventId: ChaosSpaceEventModel['id'],
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase
      .from(Table.ChaosSpaceEvent)
      .update({
        status: SpaceEventStatus.InProgress,
      })
      .eq('id', chaosSpaceEventId);
  }

  async cancelChaosSpaceEvent(
    chaosSpaceEventId: ChaosSpaceEventModel['id'],
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase
      .from(Table.ChaosSpaceEvent)
      .update({
        status: SpaceEventStatus.Canceled,
      })
      .eq('id', chaosSpaceEventId);
  }

  async submitSpecialSpaceEventScore(
    specialSpaceEventId: SpecialSpaceEventModel['id'],
    score: number,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitSpecialSpaceEventScore, {
      special_space_event_id: specialSpaceEventId,
      score,
    });
  }

  async submitGainPointsBasedOnRankSpecial(
    spaceEventId: SpecialSpaceEventModel['id'],
    spaceEventTemplateId: SpecialSpaceEventTemplateModel['id'],
    playerScoreChanges: Record<PlayerModel['id'], number>,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitSpaceEventPlayerScoreChanges, {
      space_event_id: spaceEventId,
      space_event_template_id: spaceEventTemplateId,
      player_score_changes: playerScoreChanges,
      event_description: 'Everyone gains points based on rank',
      is_chaos_space_event: false,
    });
  }

  async submitGainPointsBasedOnRankChaos(
    spaceEventId: SpecialSpaceEventModel['id'],
    spaceEventTemplateId: SpecialSpaceEventTemplateModel['id'],
    playerScoreChanges: Record<PlayerModel['id'], number>,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitSpaceEventPlayerScoreChanges, {
      space_event_id: spaceEventId,
      space_event_template_id: spaceEventTemplateId,
      player_score_changes: playerScoreChanges,
      event_description: 'Everyone gains points based on rank',
      is_chaos_space_event: true,
    });
  }

  async submitEveryoneLosesPercentageOfTheirPoints(
    spaceEventId: SpecialSpaceEventModel['id'],
    spaceEventTemplateId: SpecialSpaceEventTemplateModel['id'],
    percentageLoss: number,
    playerScoreChanges: Record<PlayerModel['id'], number>,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitSpaceEventPlayerScoreChanges, {
      space_event_id: spaceEventId,
      space_event_template_id: spaceEventTemplateId,
      player_score_changes: playerScoreChanges,
      event_description: `Everyone loses ${percentageLoss}% of their points`,
      is_chaos_space_event: true,
    });
  }

  async submitLosePercentageOfTheirPointsBasedOnTaskFailure(
    spaceEventId: SpecialSpaceEventModel['id'],
    spaceEventTemplateId: SpecialSpaceEventTemplateModel['id'],
    percentageLoss: number,
    taskName: string,
    playerScoreChanges: Record<PlayerModel['id'], number>,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitSpaceEventPlayerScoreChanges, {
      space_event_id: spaceEventId,
      space_event_template_id: spaceEventTemplateId,
      player_score_changes: playerScoreChanges,
      event_description: `Lose ${percentageLoss}% of your points if you fail to ${taskName}`,
      is_chaos_space_event: true,
    });
  }

  async submitPointSwap(
    spaceEventId: SpecialSpaceEventModel['id'],
    spaceEventTemplateId: SpecialSpaceEventTemplateModel['id'],
    player1DisplayName: string,
    player2DisplayName: string,
    playerScoreChanges: Record<PlayerModel['id'], number>,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitSpaceEventPlayerScoreChanges, {
      space_event_id: spaceEventId,
      space_event_template_id: spaceEventTemplateId,
      player_score_changes: playerScoreChanges,
      event_description: `${player1DisplayName} and ${player2DisplayName} swap points`,
      is_chaos_space_event: true,
    });
  }
}

function allSpaceEventsAreResolved(
  events: { status: SpaceEventStatus }[] | null | undefined,
): boolean {
  return !events?.length // return true if there are no chaos space events
    ? true
    : events.every((event) =>
        [SpaceEventStatus.Finished, SpaceEventStatus.Canceled].includes(
          event.status,
        ),
      );
}
