import { inject, Injectable } from '@angular/core';
import { PostgrestSingleResponse, SupabaseClient } from '@supabase/supabase-js';
import { Database, Tables } from '../util/schema';
import {
  BetModel,
  OmitAutoGeneratedColumns,
  PlayerModel,
} from '../util/supabase-types';
import {
  BetStatus,
  Function,
  realtimeUpdatesFromTable,
  Table,
} from '../util/supabase-helpers';
import {
  combineLatest,
  map,
  Observable,
  of,
  shareReplay,
  switchMap,
} from 'rxjs';
import { GameStateService } from './game-state.service';
import { PlayerService, PlayerWithUserInfo } from './player.service';
import { whenAllValuesNotNull, whenNotNull } from '../util/rxjs-helpers';
import { toSignal } from '@angular/core/rxjs-interop';
import { ChartData } from 'chart.js';
import { getCssVariableValue } from '../util/css-helpers';

@Injectable({
  providedIn: 'root',
})
export class BetService {
  private readonly supabase: SupabaseClient<Database> = inject(SupabaseClient);
  private readonly gameStateService = inject(GameStateService);
  private readonly playerService = inject(PlayerService);

  readonly bets$: Observable<BetModel[] | null> =
    // get user player id
    combineLatest({
      players: this.playerService.playersIncludingDisabled$,
      userPlayerId: this.playerService.userPlayerId$,
    }).pipe(
      switchMap(({ players, userPlayerId }) => {
        if (!players || !userPlayerId) return of(null);

        // get both requester bets and opponent bets
        return combineLatest({
          requesterBets: realtimeUpdatesFromTable(
            this.supabase,
            Table.Bet,
            `requester_player_id=eq.${userPlayerId}`,
          ),
          opponentBets: realtimeUpdatesFromTable(
            this.supabase,
            Table.Bet,
            `opponent_player_id=eq.${userPlayerId}`,
          ),
        }).pipe(
          map(({ requesterBets, opponentBets }) =>
            requesterBets
              // concatenate the 2 together
              .concat(opponentBets)
              // sort by date
              .sort(
                (a, b) =>
                  new Date(a.updated_at).getTime() -
                  new Date(b.updated_at).getTime(),
              ),
          ),
          map((bets) => linkPlayersToBets(bets, players)),
        );
      }),
      shareReplay(1),
    );

  readonly bets = toSignal(this.bets$);

  readonly resolvedBets$ = this.bets$.pipe(
    whenNotNull((bets) =>
      of(
        bets.filter((bet) =>
          [
            BetStatus.RequesterWon,
            BetStatus.OpponentWon,
            BetStatus.Push,
          ].includes(bet.status),
        ),
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly totalResolvedBets$ = this.bets$.pipe(
    whenNotNull((bets) =>
      of(
        bets.filter((bet) =>
          [
            BetStatus.Push,
            BetStatus.RequesterWon,
            BetStatus.OpponentWon,
          ].includes(bet.status),
        ).length,
      ),
    ),
  );

  readonly overallWinPercentage$ = combineLatest({
    bets: this.resolvedBets$,
    userPlayerId: this.playerService.userPlayerId$,
  }).pipe(
    whenAllValuesNotNull(({ bets, userPlayerId }) =>
      of(
        bets.length === 0
          ? 0
          : (bets.reduce((prev, bet) => {
              const userWon =
                (bet.status === BetStatus.RequesterWon &&
                  bet.requester_player_id === userPlayerId) ||
                (bet.status === BetStatus.OpponentWon &&
                  bet.opponent_player_id === userPlayerId);

              return prev + (userWon ? 1 : 0);
            }, 0) /
              bets.length) *
              100,
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly betSummaryChartData$: Observable<ChartData | null> = combineLatest({
    userPlayerId: this.playerService.userPlayerId$,
    bets: this.resolvedBets$,
  }).pipe(
    whenAllValuesNotNull(
      ({ userPlayerId, bets }): Observable<ChartData> =>
        of({
          labels: Array.from({ length: bets.length }, () => ''),
          datasets: [
            {
              label: 'Total Profit',
              data: bets.reduce<number[]>(
                (prev, bet, index) => [
                  ...prev,
                  (prev[index - 1] ?? 0) +
                    betGainOrLossAmount(bet, userPlayerId),
                ],
                [],
              ),
              borderColor: getCssVariableValue('--text-color'),
              borderWidth: 2,
              type: 'line',
            },
            {
              label: 'Bet Result',
              data:
                bets?.map((bet) => betGainOrLossAmount(bet, userPlayerId)) ??
                [],
              backgroundColor:
                bets?.map((bet) =>
                  betGainOrLossAmount(bet, userPlayerId) > 0
                    ? `${getCssVariableValue('--green-300')}70`
                    : `${getCssVariableValue('--red-300')}70`,
                ) ?? [],
              borderColor:
                bets?.map((bet) =>
                  betGainOrLossAmount(bet, userPlayerId) > 0
                    ? getCssVariableValue('--green-300')
                    : getCssVariableValue('--red-300'),
                ) ?? [],
              borderWidth: 1,
              borderRadius: 20,
              maxBarThickness: 12,
            },
          ],
        } as ChartData),
    ),
    shareReplay(1),
  );

  readonly betSummaryChartData = toSignal(this.betSummaryChartData$);

  readonly totalProfit$ = combineLatest({
    bets: this.resolvedBets$,
    userPlayerId: this.playerService.userPlayerId$,
  }).pipe(
    whenAllValuesNotNull(({ bets, userPlayerId }) =>
      of(
        bets.reduce((prev, bet) => {
          const playerIsRequester = userPlayerId === bet.requester_player_id;
          const playerIsOpponent = userPlayerId === bet.opponent_player_id;

          const playerWonAsRequester =
            bet.status === BetStatus.RequesterWon && playerIsRequester;
          const playerWonAsOpponent =
            bet.status === BetStatus.OpponentWon && playerIsOpponent;
          const playerLostAsRequester =
            bet.status === BetStatus.OpponentWon && playerIsRequester;
          const playerLostAsOpponent =
            bet.status === BetStatus.RequesterWon && playerIsOpponent;

          if (playerWonAsRequester) return prev + bet.opponent_wager;
          if (playerWonAsOpponent) return prev + bet.requester_wager;
          if (playerLostAsRequester) return prev - bet.requester_wager;
          if (playerLostAsOpponent) return prev - bet.opponent_wager;

          return prev;
        }, 0),
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly allBets$: Observable<BetModel[] | null> =
    // get both active and pending bets (should be almost entirely from the current session)
    combineLatest({
      sessionId: this.gameStateService.sessionId$,
      players: this.playerService.playersIncludingDisabled$,
    }).pipe(
      switchMap(({ sessionId, players }) => {
        if (!players || !sessionId) return of(null);

        return realtimeUpdatesFromTable(
          this.supabase,
          Table.Bet,
          `session_id=eq.${sessionId}`,
        ).pipe(
          map((bets) =>
            bets
              // sort by date
              .sort(
                (a, b) =>
                  new Date(a.updated_at).getTime() -
                  new Date(b.updated_at).getTime(),
              ),
          ),
          map((bets) => linkPlayersToBets(bets, players)),
        );
      }),
      shareReplay({ bufferSize: 1, refCount: true }),
    );

  async createBet(
    bet: OmitAutoGeneratedColumns<Tables<Table.Bet>>,
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase.from(Table.Bet).insert(bet);
  }

  async acceptBet(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetAccepted, { bet_id: id });
  }

  async pushBet(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetPush, { bet_id: id });
  }

  async submitBetRequesterWon(
    id: number,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetRequesterWon, { bet_id: id });
  }

  async submitBetOpponentWon(
    id: number,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetOpponentWon, { bet_id: id });
  }

  async cancelBetByGM(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetCanceledByGm, { bet_id: id });
  }

  async rejectBet(id: number): Promise<PostgrestSingleResponse<BetModel[]>> {
    return this.supabase
      .from(Table.Bet)
      .update({ status: BetStatus.Rejected })
      .eq('id', id)
      .select();
  }

  async cancelBetByRequester(
    id: number,
  ): Promise<PostgrestSingleResponse<BetModel[]>> {
    return this.supabase
      .from(Table.Bet)
      .update({ status: BetStatus.CanceledByRequester })
      .eq('id', id)
      .select();
  }
}

function linkPlayersToBets(
  bets: Tables<Table.Bet>[],
  players: PlayerWithUserInfo[],
): BetModel[] {
  return bets.map((bet) => {
    const requester = players.find(
      (player) => player.player_id === bet.requester_player_id,
    );
    const opponent = players.find(
      (player) => player.player_id === bet.opponent_player_id,
    );

    return {
      ...bet,
      requester,
      opponent,
      status: bet.status as BetStatus,
    };
  });
}

// function playerWonBet(bet: BetModel, playerId: PlayerModel['id']): boolean {
//   const playerIsRequester = playerId === bet.requester_player_id;
//   const playerIsOpponent = playerId === bet.opponent_player_id;
//
//   const playerWonAsRequester =
//     bet.status === BetStatus.RequesterWon && playerIsRequester;
//   const playerWonAsOpponent =
//     bet.status === BetStatus.OpponentWon && playerIsOpponent;
//
//   return playerWonAsRequester || playerWonAsOpponent;
// }

function betGainOrLossAmount(
  bet: BetModel,
  playerId: PlayerModel['id'],
): number {
  if (![BetStatus.RequesterWon, BetStatus.OpponentWon].includes(bet.status))
    return 0;

  const playerIsRequester = playerId === bet.requester_player_id;
  const playerIsOpponent = playerId === bet.opponent_player_id;

  const playerWonAsRequester =
    bet.status === BetStatus.RequesterWon && playerIsRequester;
  const playerWonAsOpponent =
    bet.status === BetStatus.OpponentWon && playerIsOpponent;
  const playerLostAsRequester =
    bet.status === BetStatus.OpponentWon && playerIsRequester;
  const playerLostAsOpponent =
    bet.status === BetStatus.RequesterWon && playerIsOpponent;

  if (playerWonAsRequester) return bet.opponent_wager;
  if (playerWonAsOpponent) return bet.requester_wager;
  if (playerLostAsRequester) return -bet.requester_wager;
  if (playerLostAsOpponent) return -bet.opponent_wager;

  return 0;
}
