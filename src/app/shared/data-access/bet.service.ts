import { inject, Injectable, Signal } from '@angular/core';
import { PostgrestSingleResponse, SupabaseClient } from '@supabase/supabase-js';
import { Database } from '../util/schema';
import {
  BetModel,
  OmitAutoGeneratedColumns,
  PlayerModel,
} from '../util/supabase-types';
import {
  realtimeUpdatesFromTable,
  Table,
  Function,
  BetStatus,
} from '../util/supabase-helpers';
import { map, Observable, shareReplay, combineLatest } from 'rxjs';
import { PlayerService } from './player.service';
import { toSignal } from '@angular/core/rxjs-interop';
import { whenNotNull } from '../util/rxjs-helpers';
import { GameStateService } from './game-state.service';

@Injectable({
  providedIn: 'root',
})
export class BetService {
  private readonly supabase: SupabaseClient<Database> = inject(SupabaseClient);
  private readonly playerService = inject(PlayerService);
  private readonly gameStateService = inject(GameStateService);

  readonly bets$: Observable<BetModel[] | null> =
    // get user player id
    this.playerService.userPlayer$.pipe(
      whenNotNull((player) =>
        // get both requester bets and opponent bets
        combineLatest({
          requesterBets: realtimeUpdatesFromTable(
            this.supabase,
            Table.Bet,
            `requester_player_id=eq.${player.player_id}`,
          ),
          opponentBets: realtimeUpdatesFromTable(
            this.supabase,
            Table.Bet,
            `opponent_player_id=eq.${player.player_id}`,
          ),
        }).pipe(
          map(({ requesterBets, opponentBets }) =>
            requesterBets
              // concatenate the 2 together
              .concat(opponentBets)
              // sort by date
              .sort(
                (a, b) =>
                  new Date(a.created_at).getTime() -
                  new Date(b.created_at).getTime(),
              ),
          ),
        ),
      ),
      shareReplay(1),
    );

  readonly bets: Signal<BetModel[] | null | undefined> = toSignal(this.bets$);

  readonly allBets$: Observable<BetModel[] | null> =
    this.gameStateService.sessionId$.pipe(
      whenNotNull((sessionId) =>
        realtimeUpdatesFromTable(
          this.supabase,
          Table.Bet,
          `session_id=eq.${sessionId}`,
        ).pipe(
          map((bets) =>
            bets.sort(
              (a, b) =>
                (a.status === BetStatus.Active ? 0 : 1) -
                (b.status === BetStatus.Active ? 0 : 1),
            ),
          ),
        ),
      ),
      shareReplay(1),
    );

  readonly allBets: Signal<BetModel[] | null | undefined> = toSignal(
    this.allBets$,
  );

  async createBet(
    bet: OmitAutoGeneratedColumns<BetModel>,
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase.from(Table.Bet).insert(bet);
  }

  async acceptBet(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetAccepted, { bet_id: id });
  }

  async pushBet(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetPush, { bet_id: id });
  }

  async submitBetRequesterWon(
    id: number,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetRequesterWon, { bet_id: id });
  }

  async submitBetOpponentWon(
    id: number,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetOpponentWon, { bet_id: id });
  }

  async cancelBetByGM(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetCanceledByGm, { bet_id: id });
  }

  async rejectBet(id: number): Promise<PostgrestSingleResponse<BetModel[]>> {
    return this.supabase
      .from(Table.Bet)
      .update({ status: BetStatus.Rejected })
      .eq('id', id)
      .select();
  }

  async cancelBetByRequester(
    id: number,
  ): Promise<PostgrestSingleResponse<BetModel[]>> {
    return this.supabase
      .from(Table.Bet)
      .update({ status: BetStatus.CanceledByRequester })
      .eq('id', id)
      .select();
  }

  async bulkCancelBets(
    playerId: PlayerModel['id'],
    includeActive: boolean,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.BulkCancelBets, {
      player_id: playerId,
      includeactive: includeActive,
    });
  }
}
