create extension if not exists "moddatetime" with schema "extensions";


create type "public"."bet_status" as enum ('pending_acceptance', 'canceled_by_requester', 'canceled_by_gm', 'rejected', 'active', 'requester_won', 'opponent_won', 'push');

create type "public"."bet_subtype" as enum ('player_loses', 'number_of_losers', 'team_position', 'score');

create type "public"."bet_type" as enum ('duel', 'special_space_event', 'chaos_space_event', 'custom', 'main_event', 'gameboard_move');

create type "public"."chaos_space_event_type" as enum ('everyone_gains_points_based_on_rank', 'everyone_loses_percentage_of_their_points', 'everyone_loses_percentage_of_their_points_based_on_task_failure', 'point_swap');

create type "public"."duel_status" as enum ('opponent_not_selected', 'wager_not_selected', 'game_not_selected', 'waiting_to_begin', 'in_progress', 'challenger_won', 'opponent_won', 'canceled');

create type "public"."event_format" as enum ('single_elimination_tournament', 'double_elimination_tournament', 'score_based_single_round');

create type "public"."gameboard_space_effect" as enum ('gain_points', 'gain_points_or_do_activity', 'special', 'duel', 'chaos', 'bank');

create type "public"."round_phase" as enum ('gameboard_moves', 'special_space_events', 'duels', 'chaos_space_events', 'event', 'waiting_for_next_round');

create type "public"."session_status" as enum ('not_started', 'in_progress', 'finished');

create type "public"."space_event_status" as enum ('event_not_selected', 'waiting_to_begin', 'in_progress', 'finished', 'canceled');

create type "public"."special_space_event_type" as enum ('player_gains_points_based_on_game_score', 'everyone_gains_points_based_on_rank');

create table "public"."bet" (
    "id" bigint generated by default as identity not null,
    "session_id" bigint not null,
    "requester_player_id" bigint not null,
    "opponent_player_id" bigint not null,
    "requester_wager" bigint not null,
    "opponent_wager" bigint not null,
    "description" text not null,
    "status" bet_status not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "bet_type" bet_type,
    "details" jsonb
);


alter table "public"."bet" enable row level security;

create table "public"."bracket" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "event_id" bigint not null,
    "data" text default ''::text
);


alter table "public"."bracket" enable row level security;

create table "public"."chaos_space_event" (
    "id" bigint generated by default as identity not null,
    "session_id" bigint not null,
    "round_number" smallint not null,
    "player_id" bigint not null,
    "template_id" bigint,
    "status" space_event_status not null,
    "results" jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "chaos_space_id" bigint not null
);


alter table "public"."chaos_space_event" enable row level security;

create table "public"."chaos_space_event_template" (
    "id" bigint generated by default as identity not null,
    "session_id" bigint not null,
    "name" text not null,
    "description" text not null,
    "details" jsonb not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "type" chaos_space_event_type not null
);


alter table "public"."chaos_space_event_template" enable row level security;

create table "public"."duel" (
    "id" bigint generated by default as identity not null,
    "challenger_player_id" bigint not null,
    "opponent_player_id" bigint,
    "game_name" text,
    "wager_percentage" smallint,
    "status" duel_status not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "session_id" bigint not null,
    "round_number" smallint not null,
    "duel_space_id" bigint not null,
    "points_gained_by_winner" bigint
);


alter table "public"."duel" enable row level security;

create table "public"."event" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "round_number" smallint not null,
    "name" text not null,
    "description" text,
    "rules" text,
    "team_size" smallint not null,
    "scoring_map" smallint[] not null,
    "image_url" text,
    "points_label" text,
    "lower_scores_are_better" boolean not null default false,
    "format" event_format not null default 'score_based_single_round'::event_format,
    "session_id" bigint not null
);


alter table "public"."event" enable row level security;

create table "public"."event_format_standard_scoring_formula" (
    "id" event_format not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "formula" text not null
);


alter table "public"."event_format_standard_scoring_formula" enable row level security;

create table "public"."event_participant" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "team_id" bigint,
    "player_id" bigint not null
);


alter table "public"."event_participant" enable row level security;

create table "public"."event_team" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "event_id" bigint not null,
    "seed" smallint,
    "name" text
);


alter table "public"."event_team" enable row level security;

create table "public"."event_team_round_score" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "team_id" bigint not null,
    "round_number" smallint not null,
    "score" bigint not null default '0'::bigint
);


alter table "public"."event_team_round_score" enable row level security;

create table "public"."game_state" (
    "id" smallint generated by default as identity not null,
    "session_id" bigint not null,
    "round_number" smallint not null,
    "session_status" session_status not null default 'not_started'::session_status,
    "game_master_user_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "round_phase" round_phase not null default 'gameboard_moves'::round_phase
);


alter table "public"."game_state" enable row level security;

create table "public"."gameboard_move" (
    "id" bigint generated by default as identity not null,
    "player_id" bigint not null,
    "round_number" smallint not null,
    "distance_traveled" smallint not null,
    "gameboard_space_id" bigint not null,
    "created_at" timestamp with time zone not null,
    "updated_at" timestamp with time zone not null
);


alter table "public"."gameboard_move" enable row level security;

create table "public"."gameboard_space" (
    "id" bigint generated by default as identity not null,
    "name" text not null default ''::text,
    "color" text not null default 'var(--gray-600)'::text,
    "icon_class" text,
    "effect" gameboard_space_effect not null default 'gain_points'::gameboard_space_effect,
    "effect_data" jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "session_id" bigint not null
);


alter table "public"."gameboard_space" enable row level security;

create table "public"."player" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "session_id" bigint not null,
    "score" bigint not null default '0'::bigint,
    "enabled" boolean not null default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."player" enable row level security;

create table "public"."player_round_score" (
    "id" bigint generated by default as identity not null,
    "player_id" bigint not null,
    "round_number" smallint not null,
    "score" bigint not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."player_round_score" enable row level security;

create table "public"."rules" (
    "id" bigint generated by default as identity not null,
    "intro" text default ''::text,
    "session_id" bigint not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "events" text,
    "gameboard" text,
    "special_space_events" text,
    "chaos_space_events" text
);


alter table "public"."rules" enable row level security;

create table "public"."session" (
    "id" bigint generated by default as identity not null,
    "name" text not null default 'Untitled'::text,
    "start_date" timestamp without time zone not null default now(),
    "end_date" timestamp without time zone not null default now(),
    "num_rounds" smallint not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "bank_balance" bigint not null default '0'::bigint
);


alter table "public"."session" enable row level security;

create table "public"."special_space_event" (
    "id" bigint generated by default as identity not null,
    "session_id" bigint not null,
    "round_number" smallint not null,
    "player_id" bigint not null,
    "template_id" bigint,
    "status" space_event_status not null,
    "results" jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "special_space_id" bigint not null
);


alter table "public"."special_space_event" enable row level security;

create table "public"."special_space_event_template" (
    "id" bigint generated by default as identity not null,
    "session_id" bigint not null,
    "name" text not null,
    "description" text not null,
    "type" special_space_event_type not null,
    "details" jsonb not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."special_space_event_template" enable row level security;

create table "public"."transaction" (
    "id" bigint generated by default as identity not null,
    "player_id" bigint not null,
    "num_points" bigint not null,
    "description" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."transaction" enable row level security;

create table "public"."user" (
    "display_name" text not null default 'Unknown'::text,
    "id" uuid not null,
    "avatar_url" text not null default 'https://hqomdxggwvkmaovkytld.supabase.co/storage/v1/object/public/avatars/default.webp'::text,
    "can_edit_profile" boolean not null default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "can_place_bets" boolean not null default true,
    "squidward_mode" boolean not null default false,
    "can_toggle_squidward_mode" boolean not null default false,
    "real_name" text not null default '''Unknown''::text'::text
);


alter table "public"."user" enable row level security;

create table "public"."user_notifications_subscription" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "notifications_subscription" json not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."user_notifications_subscription" enable row level security;

CREATE UNIQUE INDEX active_session_pkey ON public.game_state USING btree (id);

CREATE UNIQUE INDEX bet_pkey ON public.bet USING btree (id);

CREATE UNIQUE INDEX bracket_event_id_key ON public.bracket USING btree (event_id);

CREATE UNIQUE INDEX bracket_pkey ON public.bracket USING btree (id);

CREATE UNIQUE INDEX chaos_space_event_pkey ON public.chaos_space_event USING btree (id);

CREATE INDEX chaos_space_event_player_id_idx ON public.chaos_space_event USING btree (player_id);

CREATE INDEX chaos_space_event_session_id_idx ON public.chaos_space_event USING btree (session_id);

CREATE INDEX chaos_space_event_session_id_round_number_idx ON public.chaos_space_event USING btree (session_id, round_number);

CREATE INDEX chaos_space_event_special_space_id_idx ON public.chaos_space_event USING btree (chaos_space_id);

CREATE INDEX chaos_space_event_template_id_idx ON public.chaos_space_event USING btree (template_id);

CREATE UNIQUE INDEX chaos_space_event_template_pkey ON public.chaos_space_event_template USING btree (id);

CREATE INDEX chaos_space_event_template_session_id_idx ON public.chaos_space_event_template USING btree (session_id);

CREATE UNIQUE INDEX duel_pkey ON public.duel USING btree (id);

CREATE UNIQUE INDEX event_format_standard_scoring_formula_pkey ON public.event_format_standard_scoring_formula USING btree (id);

CREATE UNIQUE INDEX event_participant_pkey ON public.event_participant USING btree (id);

CREATE INDEX event_participant_player_id_idx ON public.event_participant USING btree (player_id);

CREATE INDEX event_participant_team_id_idx ON public.event_participant USING btree (team_id);

CREATE INDEX event_participant_team_id_player_id_idx ON public.event_participant USING btree (team_id, player_id);

CREATE UNIQUE INDEX event_pkey ON public.event USING btree (id);

CREATE INDEX event_session_id_idx ON public.event USING btree (session_id);

CREATE INDEX event_team_event_id_idx ON public.event_team USING btree (event_id);

CREATE UNIQUE INDEX event_team_pkey ON public.event_team USING btree (id);

CREATE UNIQUE INDEX event_team_round_score_pkey ON public.event_team_round_score USING btree (id);

CREATE INDEX event_team_round_score_team_id_idx ON public.event_team_round_score USING btree (team_id);

CREATE INDEX game_state_game_master_user_id_idx ON public.game_state USING btree (game_master_user_id);

CREATE INDEX game_state_session_id_idx ON public.game_state USING btree (session_id);

CREATE INDEX gameboard_move_gameboard_space_id_idx ON public.gameboard_move USING btree (gameboard_space_id);

CREATE INDEX gameboard_move_gameboard_space_id_player_id_idx ON public.gameboard_move USING btree (gameboard_space_id, player_id);

CREATE UNIQUE INDEX gameboard_move_pkey ON public.gameboard_move USING btree (id);

CREATE INDEX gameboard_move_player_id_idx ON public.gameboard_move USING btree (player_id);

CREATE INDEX gameboard_move_player_id_round_number_idx ON public.gameboard_move USING btree (player_id, round_number);

CREATE UNIQUE INDEX gameboard_space_pkey ON public.gameboard_space USING btree (id);

CREATE INDEX gameboard_space_session_id_idx ON public.gameboard_space USING btree (session_id);

CREATE UNIQUE INDEX player_pkey ON public.player USING btree (id);

CREATE UNIQUE INDEX player_round_score_pkey ON public.player_round_score USING btree (id);

CREATE INDEX player_round_score_player_id_idx ON public.player_round_score USING btree (player_id);

CREATE INDEX player_session_id_idx ON public.player USING btree (session_id);

CREATE INDEX player_user_id_idx ON public.player USING btree (user_id);

CREATE UNIQUE INDEX rules_pkey ON public.rules USING btree (id);

CREATE UNIQUE INDEX rules_session_id_key ON public.rules USING btree (session_id);

CREATE UNIQUE INDEX session_pkey ON public.session USING btree (id);

CREATE UNIQUE INDEX special_space_event_pkey ON public.special_space_event USING btree (id);

CREATE INDEX special_space_event_player_id_idx ON public.special_space_event USING btree (player_id);

CREATE INDEX special_space_event_session_id_idx ON public.special_space_event USING btree (session_id);

CREATE INDEX special_space_event_session_id_round_number_idx ON public.special_space_event USING btree (session_id, round_number);

CREATE INDEX special_space_event_special_space_id_idx ON public.special_space_event USING btree (special_space_id);

CREATE INDEX special_space_event_template_id_idx ON public.special_space_event USING btree (template_id);

CREATE UNIQUE INDEX special_space_event_template_pkey ON public.special_space_event_template USING btree (id);

CREATE INDEX special_space_event_template_session_id_idx ON public.special_space_event_template USING btree (session_id);

CREATE UNIQUE INDEX team_round_pair ON public.event_team_round_score USING btree (team_id, round_number);

CREATE UNIQUE INDEX transaction_pkey ON public.transaction USING btree (id);

CREATE INDEX transaction_player_id_idx ON public.transaction USING btree (player_id);

CREATE UNIQUE INDEX user_notifications_subscription_pkey ON public.user_notifications_subscription USING btree (id);

CREATE INDEX user_notifications_subscription_user_id_idx ON public.user_notifications_subscription USING btree (user_id);

CREATE UNIQUE INDEX user_pkey ON public."user" USING btree (id);

alter table "public"."bet" add constraint "bet_pkey" PRIMARY KEY using index "bet_pkey";

alter table "public"."bracket" add constraint "bracket_pkey" PRIMARY KEY using index "bracket_pkey";

alter table "public"."chaos_space_event" add constraint "chaos_space_event_pkey" PRIMARY KEY using index "chaos_space_event_pkey";

alter table "public"."chaos_space_event_template" add constraint "chaos_space_event_template_pkey" PRIMARY KEY using index "chaos_space_event_template_pkey";

alter table "public"."duel" add constraint "duel_pkey" PRIMARY KEY using index "duel_pkey";

alter table "public"."event" add constraint "event_pkey" PRIMARY KEY using index "event_pkey";

alter table "public"."event_format_standard_scoring_formula" add constraint "event_format_standard_scoring_formula_pkey" PRIMARY KEY using index "event_format_standard_scoring_formula_pkey";

alter table "public"."event_participant" add constraint "event_participant_pkey" PRIMARY KEY using index "event_participant_pkey";

alter table "public"."event_team" add constraint "event_team_pkey" PRIMARY KEY using index "event_team_pkey";

alter table "public"."event_team_round_score" add constraint "event_team_round_score_pkey" PRIMARY KEY using index "event_team_round_score_pkey";

alter table "public"."game_state" add constraint "active_session_pkey" PRIMARY KEY using index "active_session_pkey";

alter table "public"."gameboard_move" add constraint "gameboard_move_pkey" PRIMARY KEY using index "gameboard_move_pkey";

alter table "public"."gameboard_space" add constraint "gameboard_space_pkey" PRIMARY KEY using index "gameboard_space_pkey";

alter table "public"."player" add constraint "player_pkey" PRIMARY KEY using index "player_pkey";

alter table "public"."player_round_score" add constraint "player_round_score_pkey" PRIMARY KEY using index "player_round_score_pkey";

alter table "public"."rules" add constraint "rules_pkey" PRIMARY KEY using index "rules_pkey";

alter table "public"."session" add constraint "session_pkey" PRIMARY KEY using index "session_pkey";

alter table "public"."special_space_event" add constraint "special_space_event_pkey" PRIMARY KEY using index "special_space_event_pkey";

alter table "public"."special_space_event_template" add constraint "special_space_event_template_pkey" PRIMARY KEY using index "special_space_event_template_pkey";

alter table "public"."transaction" add constraint "transaction_pkey" PRIMARY KEY using index "transaction_pkey";

alter table "public"."user" add constraint "user_pkey" PRIMARY KEY using index "user_pkey";

alter table "public"."user_notifications_subscription" add constraint "user_notifications_subscription_pkey" PRIMARY KEY using index "user_notifications_subscription_pkey";

alter table "public"."bet" add constraint "bet_opponent_player_id_fkey" FOREIGN KEY (opponent_player_id) REFERENCES player(id) ON UPDATE CASCADE not valid;

alter table "public"."bet" validate constraint "bet_opponent_player_id_fkey";

alter table "public"."bet" add constraint "bet_requester_player_id_fkey" FOREIGN KEY (requester_player_id) REFERENCES player(id) ON UPDATE CASCADE not valid;

alter table "public"."bet" validate constraint "bet_requester_player_id_fkey";

alter table "public"."bet" add constraint "bet_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) not valid;

alter table "public"."bet" validate constraint "bet_session_id_fkey";

alter table "public"."bracket" add constraint "bracket_event_id_fkey" FOREIGN KEY (event_id) REFERENCES event(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."bracket" validate constraint "bracket_event_id_fkey";

alter table "public"."bracket" add constraint "bracket_event_id_key" UNIQUE using index "bracket_event_id_key";

alter table "public"."chaos_space_event" add constraint "chaos_space_event_chaos_space_id_fkey" FOREIGN KEY (chaos_space_id) REFERENCES gameboard_space(id) ON UPDATE CASCADE not valid;

alter table "public"."chaos_space_event" validate constraint "chaos_space_event_chaos_space_id_fkey";

alter table "public"."chaos_space_event" add constraint "chaos_space_event_player_id_fkey" FOREIGN KEY (player_id) REFERENCES player(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."chaos_space_event" validate constraint "chaos_space_event_player_id_fkey";

alter table "public"."chaos_space_event" add constraint "chaos_space_event_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."chaos_space_event" validate constraint "chaos_space_event_session_id_fkey";

alter table "public"."chaos_space_event" add constraint "chaos_space_event_template_id_fkey" FOREIGN KEY (template_id) REFERENCES chaos_space_event_template(id) ON UPDATE CASCADE not valid;

alter table "public"."chaos_space_event" validate constraint "chaos_space_event_template_id_fkey";

alter table "public"."chaos_space_event_template" add constraint "chaos_space_event_template_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."chaos_space_event_template" validate constraint "chaos_space_event_template_session_id_fkey";

alter table "public"."duel" add constraint "duel_challenger_player_id_fkey" FOREIGN KEY (challenger_player_id) REFERENCES player(id) ON UPDATE CASCADE not valid;

alter table "public"."duel" validate constraint "duel_challenger_player_id_fkey";

alter table "public"."duel" add constraint "duel_duel_space_id_fkey" FOREIGN KEY (duel_space_id) REFERENCES gameboard_space(id) ON UPDATE CASCADE not valid;

alter table "public"."duel" validate constraint "duel_duel_space_id_fkey";

alter table "public"."duel" add constraint "duel_opponent_player_id_fkey" FOREIGN KEY (opponent_player_id) REFERENCES player(id) ON UPDATE CASCADE not valid;

alter table "public"."duel" validate constraint "duel_opponent_player_id_fkey";

alter table "public"."duel" add constraint "duel_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."duel" validate constraint "duel_session_id_fkey";

alter table "public"."event" add constraint "event_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."event" validate constraint "event_session_id_fkey";

alter table "public"."event_participant" add constraint "event_participant_player_id_fkey" FOREIGN KEY (player_id) REFERENCES player(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."event_participant" validate constraint "event_participant_player_id_fkey";

alter table "public"."event_participant" add constraint "event_participant_team_id_fkey" FOREIGN KEY (team_id) REFERENCES event_team(id) ON UPDATE CASCADE ON DELETE SET DEFAULT not valid;

alter table "public"."event_participant" validate constraint "event_participant_team_id_fkey";

alter table "public"."event_team" add constraint "event_team_event_id_fkey" FOREIGN KEY (event_id) REFERENCES event(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."event_team" validate constraint "event_team_event_id_fkey";

alter table "public"."event_team_round_score" add constraint "event_team_round_score_team_id_fkey" FOREIGN KEY (team_id) REFERENCES event_team(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."event_team_round_score" validate constraint "event_team_round_score_team_id_fkey";

alter table "public"."event_team_round_score" add constraint "team_round_pair" UNIQUE using index "team_round_pair";

alter table "public"."game_state" add constraint "active_session_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."game_state" validate constraint "active_session_session_id_fkey";

alter table "public"."game_state" add constraint "game_state_game_master_user_id_fkey" FOREIGN KEY (game_master_user_id) REFERENCES "user"(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."game_state" validate constraint "game_state_game_master_user_id_fkey";

alter table "public"."gameboard_move" add constraint "gameboard_move_gameboard_space_id_fkey" FOREIGN KEY (gameboard_space_id) REFERENCES gameboard_space(id) ON UPDATE CASCADE not valid;

alter table "public"."gameboard_move" validate constraint "gameboard_move_gameboard_space_id_fkey";

alter table "public"."gameboard_move" add constraint "gameboard_move_player_id_fkey" FOREIGN KEY (player_id) REFERENCES player(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."gameboard_move" validate constraint "gameboard_move_player_id_fkey";

alter table "public"."gameboard_space" add constraint "gameboard_space_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."gameboard_space" validate constraint "gameboard_space_session_id_fkey";

alter table "public"."player" add constraint "player_user_id_fkey" FOREIGN KEY (user_id) REFERENCES "user"(id) ON UPDATE CASCADE not valid;

alter table "public"."player" validate constraint "player_user_id_fkey";

alter table "public"."player" add constraint "public_player_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."player" validate constraint "public_player_session_id_fkey";

alter table "public"."player_round_score" add constraint "public_player_round_score_player_id_fkey" FOREIGN KEY (player_id) REFERENCES player(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."player_round_score" validate constraint "public_player_round_score_player_id_fkey";

alter table "public"."rules" add constraint "public_rules_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."rules" validate constraint "public_rules_session_id_fkey";

alter table "public"."rules" add constraint "rules_session_id_key" UNIQUE using index "rules_session_id_key";

alter table "public"."session" add constraint "session_bank_balance_check" CHECK ((bank_balance >= 0)) not valid;

alter table "public"."session" validate constraint "session_bank_balance_check";

alter table "public"."special_space_event" add constraint "special_space_event_player_id_fkey" FOREIGN KEY (player_id) REFERENCES player(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."special_space_event" validate constraint "special_space_event_player_id_fkey";

alter table "public"."special_space_event" add constraint "special_space_event_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."special_space_event" validate constraint "special_space_event_session_id_fkey";

alter table "public"."special_space_event" add constraint "special_space_event_special_space_id_fkey" FOREIGN KEY (special_space_id) REFERENCES gameboard_space(id) ON UPDATE CASCADE not valid;

alter table "public"."special_space_event" validate constraint "special_space_event_special_space_id_fkey";

alter table "public"."special_space_event" add constraint "special_space_event_template_id_fkey" FOREIGN KEY (template_id) REFERENCES special_space_event_template(id) ON UPDATE CASCADE not valid;

alter table "public"."special_space_event" validate constraint "special_space_event_template_id_fkey";

alter table "public"."special_space_event_template" add constraint "special_space_event_template_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."special_space_event_template" validate constraint "special_space_event_template_session_id_fkey";

alter table "public"."transaction" add constraint "transaction_player_id_fkey" FOREIGN KEY (player_id) REFERENCES player(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."transaction" validate constraint "transaction_player_id_fkey";

alter table "public"."user" add constraint "user_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."user" validate constraint "user_id_fkey";

alter table "public"."user_notifications_subscription" add constraint "user_notifications_subscription_user_id_fkey" FOREIGN KEY (user_id) REFERENCES "user"(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."user_notifications_subscription" validate constraint "user_notifications_subscription_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.bulk_cancel_bets(player_id bigint, includeactive boolean)
 RETURNS void
 LANGUAGE plpgsql
AS $function$declare
  bet record;
begin
  for bet in
    select id from bet 
      where requester_player_id = player_id
        and (status = 'pending_acceptance' or
          (includeActive and status = 'active'))
  loop
    perform submit_bet_canceled_by_gm(bet.id);
  end loop;
end;$function$
;

CREATE OR REPLACE FUNCTION public.create_session(session_name text, session_start_date timestamp without time zone, session_end_date timestamp without time zone, num_rounds smallint, player_user_ids uuid[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
    new_session_id bigint;
    last_rules text;
    previous_session_id bigint;
BEGIN
    previous_session_id := (SELECT id FROM public.session ORDER BY id DESC LIMIT 1);

    -- add a row to the `session` table with this session's parameters
    INSERT INTO public.session (name, start_date, end_date, num_rounds, bank_balance, created_at, updated_at)
    VALUES (session_name, session_start_date, session_end_date, num_rounds, 0, now(), now())
    RETURNING id INTO new_session_id;

    -- add rows to the `player` table with this session's ID and the selected players' user IDs
    INSERT INTO public.player (user_id, session_id, score, enabled, created_at, updated_at)
    SELECT unnest(array(SELECT unnest(player_user_ids))), new_session_id, 0, TRUE, now(), now();

    -- copy rules from last session into this session
    INSERT INTO public.rules (session_id, created_at, updated_at, intro, events, gameboard, special_space_events, chaos_space_events)
    SELECT new_session_id, now(), now(), intro, events, gameboard, special_space_events, chaos_space_events FROM public.rules WHERE id = previous_session_id;

    -- copy chaos_space_event_template rows from previous session to new session
    INSERT INTO public.chaos_space_event_template (session_id, name, description, type, details, created_at, updated_at)
    SELECT new_session_id, name, description, type, details, now(), now()
    FROM public.chaos_space_event_template
    WHERE session_id = previous_session_id;

    -- copy special_space_event_template rows from previous session to new session
    INSERT INTO public.special_space_event_template (session_id, name, description, type, details, created_at, updated_at)
    SELECT new_session_id, name, description, type, details, now(), now()
    FROM public.special_space_event_template
    WHERE session_id = previous_session_id;

    -- copy gameboard_space rows from previous session to new session
    INSERT INTO public.gameboard_space (name, color, icon_class, effect, effect_data, created_at, updated_at, session_id)
    SELECT name, color, icon_class, effect, effect_data, now(), now(), new_session_id
    FROM public.gameboard_space
    WHERE session_id = previous_session_id;

    -- copy event rows from previous session to new session
    INSERT INTO public.event (round_number, name, description, rules, team_size, scoring_map, image_url, points_label, lower_scores_are_better, format, created_at, updated_at, session_id)
    SELECT round_number, name, description, rules, team_size, scoring_map, image_url, points_label, lower_scores_are_better, format, now(), now(), new_session_id
    FROM public.event
    WHERE session_id = previous_session_id;

    -- update the `game_state` table to use the new session ID, session status `not_started`, `round_number` 0, and round phase `waiting_for_next_round`
    UPDATE public.game_state
    SET session_id = new_session_id, round_number = 0, session_status = 'not_started', round_phase = 'waiting_for_next_round'
    WHERE id = 1;

    RETURN;
END;$function$
;

CREATE OR REPLACE FUNCTION public.delete_gameboard_space(v_gameboard_space_id bigint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- disallow deleting a space a player has already landed on
    IF EXISTS (SELECT 1 FROM gameboard_move WHERE gameboard_space_id = v_gameboard_space_id) THEN
        RAISE EXCEPTION 'Cannot delete a space a player has already landed on';
    END IF;

    -- disallow deleting a session's only duel space
    IF (SELECT effect FROM gameboard_space WHERE id = v_gameboard_space_id) = 'duel' THEN
        IF NOT EXISTS (SELECT 1 FROM gameboard_space WHERE session_id = (SELECT session_id FROM gameboard_space WHERE id = v_gameboard_space_id) AND effect = 'duel' AND id <> v_gameboard_space_id) THEN
            RAISE EXCEPTION 'Must have at least 1 duel space';
        END IF;
    END IF;

    DELETE FROM gameboard_space WHERE id = v_gameboard_space_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.end_round(_round_number integer, team_score_changes jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
    event_team_id int8;
    points int8;
	team_player_id int8;
BEGIN
    FOR event_team_id, points IN SELECT * FROM jsonb_each_text(team_score_changes) LOOP
		for team_player_id In
			select player_id from event_participant where team_id = event_team_id
		loop
			-- add trasnsaction
			INSERT INTO public.transaction (player_id, num_points, description)
			VALUES (team_player_id, points, 'Points earned during round ' || _round_number);

			-- save player round score snapshot
			INSERT INTO public.player_round_score (player_id, round_number, score)
			VALUES (team_player_id, _round_number, 
				(SELECT score FROM public.player WHERE id = team_player_id)
			);
		end loop;
    END LOOP;
    UPDATE public.game_state
    SET round_number = round_number + 1, round_phase = 'gameboard_moves'
    WHERE id = 1;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_all_scores_from_session(sessionid integer)
 RETURNS SETOF record
 LANGUAGE sql
AS $function$ SELECT p.user_id, p.score, u.display_name, u.avatar_url FROM player p JOIN "user" u ON p.user_id = u.id WHERE p.session_id = sessionId ORDER BY score DESC; $function$
;

CREATE OR REPLACE FUNCTION public.get_duel_history_for_session(sessionid bigint)
 RETURNS SETOF json
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT json_build_object(
        'id', d.id,
        'round_number', d.round_number,
        'challenger_user_id', p1.user_id,
        'challenger_display_name', u1.display_name,
        'challenger_avatar_url', u1.avatar_url,
        'opponent_user_id', p2.user_id,
        'opponent_display_name', u2.display_name,
        'opponent_avatar_url', u2.avatar_url,
        'status', d.status,
        'game_name', d.game_name,
        'wager_percentage', d.wager_percentage,
        'points_gained_by_winner', d.points_gained_by_winner
    )
    FROM duel d
    JOIN player p1 ON d.challenger_player_id = p1.id
    JOIN "user" u1 ON p1.user_id = u1.id
    JOIN player p2 ON d.opponent_player_id = p2.id
    JOIN "user" u2 ON p2.user_id = u2.id
    WHERE d.session_id = sessionid
    AND d.status IN ('challenger_won', 'opponent_won')
    ORDER BY d.round_number ASC, d.updated_at DESC;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_player_duel_stats_for_session(sessionid bigint)
 RETURNS SETOF json
 LANGUAGE plpgsql
AS $function$
DECLARE
    player_record RECORD;
    player_stats json;
BEGIN
    FOR player_record IN
        SELECT p.user_id, u.display_name, u.avatar_url, p.id
        FROM player p
        JOIN "user" u ON p.user_id = u.id
        WHERE p.session_id = sessionid
    LOOP
        SELECT json_build_object(
            'user_id', player_record.user_id,
            'display_name', player_record.display_name,
            'avatar_url', player_record.avatar_url,
            'num_duels_participated', COALESCE((SELECT COUNT(*) FROM duel WHERE (challenger_player_id = player_record.id OR opponent_player_id = player_record.id) AND status IN ('challenger_won', 'opponent_won')), 0),
            'num_duels_won', COALESCE((SELECT COUNT(*) FROM duel WHERE (challenger_player_id = player_record.id AND status = 'challenger_won') OR (opponent_player_id = player_record.id AND status = 'opponent_won')), 0),
            'total_points_won', COALESCE((SELECT SUM(points_gained_by_winner) FROM duel WHERE (challenger_player_id = player_record.id AND status = 'challenger_won') OR (opponent_player_id = player_record.id AND status = 'opponent_won')), 0),
            'total_points_lost', COALESCE((SELECT SUM(points_gained_by_winner) FROM duel WHERE (challenger_player_id = player_record.id AND status = 'opponent_won') OR (opponent_player_id = player_record.id AND status = 'challenger_won')), 0) * -1
        ) INTO player_stats;
        RETURN NEXT player_stats;
    END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_player_round_scores_from_session(sessionid bigint)
 RETURNS TABLE(player_id bigint, display_name text, avatar_url text, scores bigint[])
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT pr.player_id, u.display_name, u.avatar_url, array_agg(pr.score ORDER BY pr.round_number) as scores
    FROM player_round_score pr
    JOIN player p ON pr.player_id = p.id
    JOIN "user" u ON p.user_id = u.id
    WHERE p.session_id = sessionId
    GROUP BY pr.player_id, u.display_name, u.avatar_url
    ORDER BY pr.player_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_roll_history_for_session(sessionid bigint)
 RETURNS SETOF json
 LANGUAGE plpgsql
AS $function$ 
DECLARE 
    player_record RECORD; 
    gameboard_move_record RECORD; 
    result json; 
    gameboard_moves json[]; 
    max_round_number INT; 
BEGIN 
    SELECT MAX(round_number) INTO max_round_number 
    FROM gameboard_move 
    WHERE player_id IN ( 
        SELECT id 
        FROM player 
        WHERE session_id = sessionid 
    ); 
    
    FOR player_record IN 
        SELECT p.id AS player_id, u.display_name, u.avatar_url, u.id AS user_id 
        FROM player p 
        JOIN "user" u ON p.user_id = u.id 
        WHERE p.session_id = sessionid 
    LOOP 
        gameboard_moves := ARRAY[]::json[]; 
        
        FOR i IN 1..max_round_number LOOP 
            SELECT gm.distance_traveled, gs.color, gs.icon_class 
            INTO gameboard_move_record 
            FROM gameboard_move gm 
            JOIN gameboard_space gs ON gm.gameboard_space_id = gs.id 
            WHERE gm.player_id = player_record.player_id 
            AND gm.round_number = i; 
            
            gameboard_moves := array_append(gameboard_moves, 
                json_build_object( 
                    'distance', gameboard_move_record.distance_traveled, 
                    'gameboard_space', json_build_object( 
                        'color', gameboard_move_record.color, 
                        'icon_class', gameboard_move_record.icon_class 
                    ) 
                ) 
            ); 
        END LOOP; 
        
        result := json_build_object( 
            'player_id', player_record.player_id, 
            'user_id', player_record.user_id, 
            'display_name', player_record.display_name, 
            'avatar_url', player_record.avatar_url, 
            'gameboard_moves', gameboard_moves 
        ); 
        
        RETURN NEXT result; 
    END LOOP; 
END; 
$function$
;

CREATE OR REPLACE FUNCTION public.get_space_stats_for_session(sessionid bigint)
 RETURNS SETOF record
 LANGUAGE sql
AS $function$
    SELECT p.user_id, gm.player_id, u.display_name, u.avatar_url, json_object_agg(gm.gameboard_space_id, cnt) as space_stats
    FROM gameboard_move gm
    JOIN player p ON gm.player_id = p.id
    JOIN "user" u ON p.user_id = u.id
    JOIN (
        SELECT player_id, gameboard_space_id, count(*) as cnt
        FROM gameboard_move
        WHERE player_id IN (SELECT player_id FROM player WHERE session_id = sessionid)
        GROUP BY player_id, gameboard_space_id
    ) counts ON gm.player_id = counts.player_id AND gm.gameboard_space_id = counts.gameboard_space_id
    GROUP BY p.user_id, gm.player_id, u.display_name, u.avatar_url;
$function$
;

create or replace view "public"."lifetime_user_stats" as  SELECT p.user_id,
    ceil(sum(p.score)) AS lifetime_score,
    ceil(avg(p.score)) AS average_score,
    count(p.id) AS num_sessions,
    u.display_name,
    u.avatar_url
   FROM (player p
     JOIN "user" u ON ((p.user_id = u.id)))
  GROUP BY p.user_id, u.display_name, u.avatar_url
  ORDER BY (ceil(sum(p.score))) DESC;


CREATE OR REPLACE FUNCTION public.log_round_moves(playermoves json, roundnumber integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
    v_player_id INT;
    distance_traveled INT;
    v_gameboard_space_id INT;
    points_gained INT;
    space_name TEXT;
    gameboard_space_effect TEXT;
    decision TEXT;
    values JSON;
    num_players_who_landed_on_bank_space INT;
    v_bank_balance INT;
    points_to_gain INT;
    v_session_id BIGINT;
BEGIN
    num_players_who_landed_on_bank_space := (SELECT COUNT(*) FROM json_object_keys(playerMoves::json) pm WHERE (playerMoves->pm->>'gameboardSpaceId')::INT IN (SELECT id FROM gameboard_space gs WHERE gs.effect = 'bank'));

    FOR v_player_id, values IN SELECT * FROM json_each_text(playerMoves::json)
    LOOP
        v_gameboard_space_id := values -> 'gameboardSpaceId';
        distance_traveled := values -> 'distanceTraveled';
        
        SELECT effect, effect_data->>'pointsGained', name INTO gameboard_space_effect, points_gained, space_name
        FROM gameboard_space WHERE id = v_gameboard_space_id;
        
        SELECT values ->> 'decision' INTO decision;
        
        -- log gameboard move
        INSERT INTO gameboard_move (player_id, round_number, distance_traveled, gameboard_space_id, created_at, updated_at)
        VALUES (v_player_id, roundNumber, distance_traveled, v_gameboard_space_id, now(), now());
        
        -- Only add points when either:
        IF gameboard_space_effect = 'gain_points' OR
           (gameboard_space_effect = 'gain_points_or_do_activity' AND decision = 'points') THEN
            INSERT INTO transaction (player_id, num_points, description, created_at, updated_at)
            VALUES (v_player_id, points_gained, space_name || ' Space on turn ' || roundNumber, now(), now());

                -- add lost points to the bank balance
                IF points_gained < 0 THEN
                    v_session_id := (SELECT p.session_id from player p WHERE p.id = v_player_id);

                    UPDATE session
                    SET bank_balance = bank_balance - points_gained
                    WHERE id = v_session_id;
                END IF;
        END IF;
        
        -- Add Special Space Events for special spaces:
        IF gameboard_space_effect = 'special' THEN
            INSERT INTO special_space_event (session_id, round_number, player_id, status, special_space_id, created_at, updated_at)
            VALUES ((SELECT session_id FROM player p WHERE p.id = v_player_id), roundNumber, v_player_id, 'event_not_selected', v_gameboard_space_id, now(), now());
        END IF;
        
        -- Add duels for duel spaces:
        IF gameboard_space_effect = 'duel' THEN
            INSERT INTO duel (session_id, round_number, challenger_player_id, status, duel_space_id, created_at, updated_at)
            VALUES ((SELECT session_id FROM player p WHERE p.id = v_player_id), roundNumber, v_player_id, 'opponent_not_selected', v_gameboard_space_id, now(), now());
        END IF;
        
        -- Add Chaos Space Events for special spaces:
        IF gameboard_space_effect = 'chaos' THEN
            INSERT INTO chaos_space_event (session_id, round_number, player_id, status, chaos_space_id, created_at, updated_at)
            VALUES ((SELECT session_id FROM player p WHERE p.id = v_player_id), roundNumber, v_player_id, 'event_not_selected', v_gameboard_space_id, now(), now());
        END IF;
        
        -- Distribute bank balance when player(s) land on bank space
        IF gameboard_space_effect = 'bank' THEN
            SELECT bank_balance INTO v_bank_balance FROM session WHERE id = (SELECT session_id FROM player WHERE id = v_player_id);
            
            points_to_gain := v_bank_balance / num_players_who_landed_on_bank_space;
            
            INSERT INTO transaction (player_id, num_points, description, created_at, updated_at)
            VALUES (v_player_id, points_to_gain, space_name || ' Space on turn ' || roundNumber, now(), now());
        END IF;
    END LOOP;

    -- Reset bank balance to 0 if someone landed on the bank space
    IF num_players_who_landed_on_bank_space > 0 THEN
        UPDATE session SET bank_balance = 0 WHERE id = (SELECT session_id FROM player WHERE id = v_player_id);
    END IF;
    
    -- go to next round phase
    UPDATE game_state SET round_phase = 'special_space_events' WHERE id = 1;
    
    RETURN;
END;$function$
;

create or replace view "public"."moves_for_current_round" as  SELECT gm.player_id,
    gm.gameboard_space_id,
    u.display_name,
    u.avatar_url
   FROM ((gameboard_move gm
     JOIN player p ON ((gm.player_id = p.id)))
     JOIN "user" u ON ((p.user_id = u.id)))
  WHERE ((gm.round_number = ( SELECT game_state.round_number
           FROM game_state
          ORDER BY game_state.id
         LIMIT 1)) AND (gm.player_id IN ( SELECT gm.player_id
           FROM player
          WHERE (player.session_id = ( SELECT game_state.session_id
                   FROM game_state
                  ORDER BY game_state.id
                 LIMIT 1)))));


CREATE OR REPLACE FUNCTION public.override_bank_balance(data json)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_session_id bigint := (data->>'sessionId')::bigint;
    v_change_amount bigint := (data->>'change')::bigint;
    v_replace_value boolean := (data->>'replace')::boolean;
BEGIN
    IF v_replace_value THEN
        UPDATE session
        SET bank_balance = v_change_amount
        WHERE id = v_session_id;
    ELSE
        UPDATE session
        SET bank_balance = bank_balance + v_change_amount
        WHERE id = v_session_id;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.override_points(data json, add_lost_points_to_bank_balance boolean)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    player_id bigint := (data->>'playerId')::bigint;
    change_amount bigint := (data->>'change')::bigint;
    replace_value boolean := (data->>'replace')::boolean;
    comment_text text := (data->>'comment');
    player_score bigint;
    v_transaction_amount BIGINT;
    v_session_id BIGINT;
BEGIN
    SELECT score INTO player_score FROM player WHERE id = player_id;

    IF replace_value THEN
        v_transaction_amount := change_amount - player_score;
    ELSE
        v_transaction_amount := change_amount;
    END IF;

    INSERT INTO transaction (player_id, num_points, description)
    VALUES (player_id, v_transaction_amount, 
        CASE WHEN comment_text = '' THEN 'GM Discretion' ELSE 'GM Discretion: ' || comment_text END);

    -- add lost points to the bank balance
    IF v_transaction_amount < 0 AND add_lost_points_to_bank_balance THEN
        v_session_id := (SELECT p.session_id FROM player p WHERE p.id = player_id);
        
        UPDATE session
        SET bank_balance = bank_balance - v_transaction_amount
        WHERE id = v_session_id;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reorder_events(events_with_new_round_number json)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    event_id bigint;
    new_round_number smallint;
BEGIN
    FOR event_id, new_round_number IN SELECT * FROM json_each_text(events_with_new_round_number)
    LOOP
        UPDATE public.event
        SET round_number = new_round_number
        WHERE id = event_id;
    END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.resolve_chaos_event_bets()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$declare
	chaos_status space_event_status;
	chaos_results jsonb;
	bet_data jsonb;
	bet_chaos_id int8;
	bet_subtype bet_subtype;
	bet_player_id int8;
	bet_is_loser boolean;
	bet_direction_is_over boolean;
	bet_ou_value float;
	player_score int8;
	player_score_changed boolean;
	number_of_losers int8;
	row_record record;
begin
	select status, chaos_space_event.results into chaos_status, chaos_results from chaos_space_event where id=NEW.id;
	
	if chaos_status != 'finished' then
		return NEW;
	end if;
	
	for row_record in
		select * from bet where bet_type = 'chaos_space_event' and status = 'active'
	loop
		bet_data := row_record.details;
		bet_chaos_id := (bet_data->>'chaosEventId')::int8;
		if bet_chaos_id = NEW.id then
			bet_subtype := (bet_data->>'subtype')::bet_subtype;
			if bet_subtype = 'player_loses' then
				bet_player_id := (bet_data->>'playerId')::int8;
				select score into player_score from player where id=bet_player_id;
				if player_score=0 then
					perform submit_bet_push(row_record.id);
					continue;
				end if;
				bet_is_loser := bet_data->>'isLoser';
				player_score_changed := (chaos_results->>(bet_player_id::text))::int8 != 0;
				if bet_is_loser = player_score_changed then
					perform submit_bet_requester_won(row_record.id);
				else
					perform submit_bet_opponent_won(row_record.id);
				end if;
			end if;
			if bet_subtype = 'number_of_losers' then
				bet_direction_is_over := bet_data->>'directionIsOver';
				bet_ou_value := (bet_data->>'ouValue')::float;
				select count(key) into number_of_losers 
					from jsonb_each(chaos_results) 
					where value::float != 0;
				if bet_ou_value = number_of_losers then
					perform submit_bet_push(row_record.id);
					continue;
				end if;
				if (bet_direction_is_over and number_of_losers > bet_ou_value)
					or ((not bet_direction_is_over) and number_of_losers < bet_ou_value) then
					perform submit_bet_requester_won(row_record.id);
					continue;
				end if;
				perform submit_bet_opponent_won(row_record.id);
			end if;
		end if;
	end loop;
	return NEW;
end;$function$
;

CREATE OR REPLACE FUNCTION public.resolve_duel_bets()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$declare
	chaos_status space_event_status;
	chaos_results jsonb;
	bet_data jsonb;
	bet_chaos_id int8;
	bet_subtype bet_subtype;
	bet_player_id int8;
	bet_is_loser boolean;
	player_score int8;
	player_score_changed boolean;
	row_record record;
begin
	select status, results into chaos_status, chaos_results from chaos_space_event where id=NEW.id;
	
	if chaos_status != 'finished' then
		return NEW;
	end if;
	
	for row_record in
		select * from bet where bet_type = 'chaos_space_event' and status = 'active'
	loop
		bet_data := row_record.details;
		bet_chaos_id := cast(bet_data->>'chaosEventId' as int8);
		if bet_chaos_id = NEW.id then
			bet_subtype := cast(bet_data->>'subtype' as bet_subtype);
			if bet_subtype = 'player_loses' then
				bet_player_id := cast(bet_data->>'playerId' as int8);
				select score into player_score from player where id=bet_player_id;
				if player_score=0 then
					perform submit_bet_push(row_record.id);
					continue;
				end if;
				bet_is_loser := cast(bet_data->>'isLoser' as boolean);
				player_score_changed := cast(chaos_results->>bet_player_id as int8) != 0;
				if bet_is_loser = player_score_changed then
					perform submit_bet_requester_won(row_record.id);
				else
					perform submit_bet_opponent_won(row_record.id);
				end if;
			end if;
		end if;
	end loop;
	return NEW;
end;$function$
;

CREATE OR REPLACE FUNCTION public.resolve_gameboard_move_bets()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$declare
	bet_row RECORD;
begin
	for bet_row in
		select
			id,
			status,
			(details->>'gameboardSpaceId')::int8 as gameboard_space_id
		from
			bet
		where
			bet_type = 'gameboard_move' and
			(details->>'playerId')::int8 = NEW.player_id
	loop
		if bet_row.status = 'pending_acceptance' then
			--Cancel pending bets that would be recontextualized
			perform submit_bet_canceled_by_gm(bet_row.id);
			continue;
		end if;
		if bet_row.status != 'active' then
			continue;
		end if;
		
		if NEW.gameboard_space_id = bet_row.gameboard_space_id then
			perform submit_bet_requester_won(bet_row.id);
		else
			perform submit_bet_opponent_won(bet_row.id);
		end if;
	end loop;
	return NEW;
end;$function$
;

CREATE OR REPLACE FUNCTION public.resolve_ss_event_bets()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$declare
	ss_event_results jsonb;
	ss_event_status space_event_status;
	ss_event_score float;
	bet_data jsonb;
	bet_ss_event_id int8;
	bet_direction_is_over boolean;
	bet_ou_value float;
	row_record RECORD;
begin
  select status, results into ss_event_status, ss_event_results from special_space_event where id = NEW.id;

  if ss_event_status != 'finished' then
		return NEW;
  end if;
  
  ss_event_score := CAST(ss_event_results->>'score' as float);

  FOR row_record in  
		select * from bet where bet_type = 'special_space_event' and status = 'active'
  loop
		bet_data := row_record.details;
		bet_ss_event_id := cast(bet_data->>'ssEventId' as int8);
		if bet_ss_event_id = NEW.id then
	  	bet_direction_is_over := bet_data->>'directionIsOver';
	  	bet_ou_value := CAST(bet_data->>'ouValue' as float);
	  	if bet_ou_value = ss_event_score then
				perform submit_bet_push(row_record.id);
	  	elsif (bet_direction_is_over and ss_event_score > bet_ou_value)
				or ((not bet_direction_is_over) and ss_event_score < bet_ou_value) then
				perform submit_bet_requester_won(row_record.id);
	  	else
				perform submit_bet_opponent_won(row_record.id);
	  	end if;
		end if;
  end loop;
  return NEW;
end;$function$
;

CREATE OR REPLACE FUNCTION public.set_new_event_round_number()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
    NEW.round_number := COALESCE((SELECT MAX(round_number) FROM event WHERE session_id = NEW.session_id) + 1, -1);
    RETURN NEW;
END;$function$
;

create or replace view "public"."special_space_events_for_current_round" as  SELECT sse.id,
    sse.player_id,
    sse.template_id,
    sset.name AS template_name,
    sse.status,
    u.display_name,
    u.avatar_url
   FROM (((special_space_event sse
     JOIN player p ON ((sse.player_id = p.id)))
     JOIN "user" u ON ((p.user_id = u.id)))
     LEFT JOIN special_space_event_template sset ON ((sse.template_id = sset.id)))
  WHERE ((sse.round_number = ( SELECT gs.round_number
           FROM game_state gs
          WHERE (gs.id = 1))) AND (sse.session_id = ( SELECT gs.session_id
           FROM game_state gs
          WHERE (gs.id = 1))));


CREATE OR REPLACE FUNCTION public.start_session_early(now timestamp without time zone)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- set start time to "now" (from the client, so timezone is correct)
    UPDATE public.session
    SET start_date = now
    WHERE id = (SELECT session_id FROM public.game_state WHERE id = 1);

    -- set session status to in_progress
    UPDATE public.game_state
    SET session_status = 'in_progress'
    WHERE id = 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.submit_bet_accepted(bet_id bigint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
  v_requester_player_id int8;
  v_requester_wager int8;
  v_requester_name text;
  v_opponent_player_id int8;
  v_opponent_wager int8;
  v_opponent_name text;
  v_description text;
BEGIN
  SELECT 
    requester_player_id,
    requester_wager,
    opponent_player_id,
    opponent_wager,
    description
  INTO
    v_requester_player_id,
    v_requester_wager,
    v_opponent_player_id,
    v_opponent_wager,
    v_description
  FROM bet
  WHERE id = bet_id;

  SELECT u.display_name
  INTO v_requester_name
  FROM player p
  JOIN "user" u ON p.user_id = u.id
  WHERE p.id = v_requester_player_id;

  SELECT u.display_name
  INTO v_opponent_name
  FROM player p
  JOIN "user" u ON p.user_id = u.id
  WHERE p.id = v_opponent_player_id;

  INSERT INTO transaction 
    (player_id, 
    num_points, 
    description, 
    created_at, 
    updated_at)
  VALUES (
    v_requester_player_id, 
    -v_requester_wager,
    'Wager for bet against ' || v_opponent_name || ' that ''' || v_description || '''',
    now(),
    now());

  INSERT INTO transaction 
    (player_id, 
    num_points, 
    description, 
    created_at, 
    updated_at)
  VALUES (
    v_opponent_player_id, 
    -v_opponent_wager,
    'Wager for ' || v_requester_name || '''s bet that ''' || v_description || '''',
    now(),
    now());

  UPDATE bet
  SET status = 'active'
  WHERE id = bet_id;
END;$function$
;

CREATE OR REPLACE FUNCTION public.submit_bet_canceled_by_gm(bet_id bigint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
  v_requester_player_id int8;
  v_requester_wager int8;
  v_requester_name text;
  v_opponent_player_id int8;
  v_opponent_wager int8;
  v_opponent_name text;
  v_description text;
  v_old_status bet_status;
BEGIN
  SELECT 
    requester_player_id,
    requester_wager,
    opponent_player_id,
    opponent_wager,
    description,
    status
  INTO
    v_requester_player_id,
    v_requester_wager,
    v_opponent_player_id,
    v_opponent_wager,
    v_description,
    v_old_status
  FROM bet
  WHERE id = bet_id;

  IF v_old_status = 'active' THEN
    SELECT u.display_name
    INTO v_requester_name
    FROM player p
    JOIN "user" u ON p.user_id = u.id
    WHERE p.id = v_requester_player_id;

    SELECT u.display_name
    INTO v_opponent_name
    FROM player p
    JOIN "user" u ON p.user_id = u.id
    WHERE p.id = v_opponent_player_id;

    INSERT INTO transaction 
      (player_id, 
      num_points, 
      description, 
      created_at, 
      updated_at)
    VALUES (
      v_requester_player_id, 
      v_requester_wager,
      'Canceled by GM: Bet against ' || v_opponent_name || ' that ''' || v_description || '''',
      now(),
      now());

    INSERT INTO transaction 
      (player_id, 
      num_points, 
      description, 
      created_at, 
      updated_at)
    VALUES (
      v_opponent_player_id, 
      v_opponent_wager,
      'Canceled by GM: ' || v_requester_name || '''s bet that ''' || v_description || '''',
      now(),
      now());
  END IF;

  UPDATE bet
  SET status = 'canceled_by_gm'
  WHERE id = bet_id;
END;$function$
;

CREATE OR REPLACE FUNCTION public.submit_bet_opponent_won(bet_id bigint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
  v_requester_player_id int8;
  v_requester_wager int8;
  v_requester_name text;
  v_opponent_player_id int8;
  v_opponent_wager int8;
  v_description text;
BEGIN
  SELECT 
    requester_player_id,
    requester_wager,
    opponent_player_id,
    opponent_wager,
    description
  INTO
    v_requester_player_id,
    v_requester_wager,
    v_opponent_player_id,
    v_opponent_wager,
    v_description
  FROM bet
  WHERE id = bet_id;

  SELECT u.display_name
  INTO v_requester_name
  FROM player p
  JOIN "user" u ON p.user_id = u.id
  WHERE p.id = v_requester_player_id;

  INSERT INTO transaction 
    (player_id, 
    num_points, 
    description, 
    created_at, 
    updated_at)
  VALUES (
    v_opponent_player_id, 
    v_opponent_wager + v_requester_wager,
    'Won ' || v_requester_name || '''s bet that ''' || v_description || '''',
    now(),
    now());

  UPDATE bet
  SET status = 'opponent_won'
  WHERE id = bet_id;
END;$function$
;

CREATE OR REPLACE FUNCTION public.submit_bet_push(bet_id bigint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
  v_requester_player_id int8;
  v_requester_wager int8;
  v_requester_name text;
  v_opponent_player_id int8;
  v_opponent_wager int8;
  v_opponent_name text;
  v_description text;
BEGIN
  SELECT 
    requester_player_id,
    requester_wager,
    opponent_player_id,
    opponent_wager,
    description
  INTO
    v_requester_player_id,
    v_requester_wager,
    v_opponent_player_id,
    v_opponent_wager,
    v_description
  FROM bet
  WHERE id = bet_id;

  SELECT u.display_name
  INTO v_requester_name
  FROM player p
  JOIN "user" u ON p.user_id = u.id
  WHERE p.id = v_requester_player_id;

  SELECT u.display_name
  INTO v_opponent_name
  FROM player p
  JOIN "user" u ON p.user_id = u.id
  WHERE p.id = v_opponent_player_id;

  INSERT INTO transaction 
    (player_id, 
    num_points, 
    description, 
    created_at, 
    updated_at)
  VALUES (
    v_requester_player_id, 
    v_requester_wager,
    'Push for bet against ' || v_opponent_name || ' that ''' || v_description || '''',
    now(),
    now());

  INSERT INTO transaction 
    (player_id, 
    num_points, 
    description, 
    created_at, 
    updated_at)
  VALUES (
    v_opponent_player_id, 
    v_opponent_wager,
    'Push for ' || v_requester_name || '''s bet that ''' || v_description || '''',
    now(),
    now());

  UPDATE bet
  SET status = 'push'
  WHERE id = bet_id;
END;$function$
;

CREATE OR REPLACE FUNCTION public.submit_bet_requester_won(bet_id bigint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
  v_requester_player_id int8;
  v_requester_wager int8;
  v_opponent_player_id int8;
  v_opponent_wager int8;
  v_opponent_name text;
  v_description text;
BEGIN
  SELECT 
    requester_player_id,
    requester_wager,
    opponent_player_id,
    opponent_wager,
    description
  INTO
    v_requester_player_id,
    v_requester_wager,
    v_opponent_player_id,
    v_opponent_wager,
    v_description
  FROM bet
  WHERE id = bet_id;

  SELECT u.display_name
  INTO v_opponent_name
  FROM player p
  JOIN "user" u ON p.user_id = u.id
  WHERE p.id = v_opponent_player_id;

  INSERT INTO transaction 
    (player_id, 
    num_points, 
    description, 
    created_at, 
    updated_at)
  VALUES (
    v_requester_player_id, 
    v_requester_wager + v_opponent_wager,
    'Won bet against ' || v_opponent_name || ' that ''' || v_description || '''',
    now(),
    now());

  UPDATE bet
  SET status = 'requester_won'
  WHERE id = bet_id;
END;$function$
;

CREATE OR REPLACE FUNCTION public.submit_duel_results(duel_id bigint, challenger_won boolean, player_score_changes json)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    duel_status duel_status;
    winner_id bigint;
    winner_display_name text;
    loser_id bigint;
    loser_display_name text;
    duel_round_number smallint;
    duel_game_name text;
    player_id bigint;
    transaction_description text;
    player_score bigint;
BEGIN
    -- Update duel status based on challenger_won parameter
    IF challenger_won THEN
        duel_status := 'challenger_won';
        winner_id := (SELECT challenger_player_id FROM duel WHERE id = duel_id);
        loser_id := (SELECT opponent_player_id FROM duel WHERE id = duel_id);
    ELSE
        duel_status := 'opponent_won';
        winner_id := (SELECT opponent_player_id FROM duel WHERE id = duel_id);
        loser_id := (SELECT challenger_player_id FROM duel WHERE id = duel_id);
    END IF;

    -- Get round number and game name
    SELECT round_number, game_name
    INTO duel_round_number, duel_game_name
    FROM duel
    WHERE id = duel_id;

    -- Get winning player's display name from the user table
    SELECT u.display_name
    INTO winner_display_name
    FROM player p
    JOIN "user" u ON p.user_id = u.id
    WHERE p.id = winner_id;

    -- Get losing player's display name from the user table
    SELECT u.display_name
    INTO loser_display_name
    FROM player p
    JOIN "user" u ON p.user_id = u.id
    WHERE p.id = loser_id;

    -- Loop through player_score_changes JSON object
    FOR player_id, player_score IN SELECT * FROM json_each_text(player_score_changes)
    LOOP
        -- Insert transaction record for each player
        INSERT INTO transaction (player_id, num_points, description, created_at, updated_at)
        VALUES (player_id, player_score,
            CASE WHEN (player_id = winner_id)
                THEN 'Duel in turn ' || duel_round_number || ': You beat ' || loser_display_name || ' in ' || duel_game_name
                ELSE 'Duel in turn ' || duel_round_number || ': ' || winner_display_name || ' beat you in ' || duel_game_name
            END,
            now(), now()
        );

        -- Update points_gained_by_winner for the winner
        IF player_id = winner_id THEN
            UPDATE duel
            SET points_gained_by_winner = player_score
            WHERE id = duel_id;
        END IF;
    END LOOP;

    -- Update duel status
    UPDATE duel
    SET status = duel_status
    WHERE id = duel_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.submit_event_scores(team_scores jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
  event_team RECORD;
  bet_row RECORD;
  position_from_bottom int;
BEGIN
	create temp table if not exists temp_team_scores as
		select
			(value->>'team_id')::int8 as team_id,
			(value->>'score')::int8 as score,
			(value->>'position')::int as position
		from
			jsonb_array_elements(team_scores);
		
	create temp table if not exists temp_team_position_bets as
		select
			id,
			status,
			(details->>'teamId')::int8 as team_id,
			(details->>'eventId')::int8 as event_id,
			(details->>'numberOfTeams')::int as number_of_teams,
			(details->>'directionIsTop')::boolean as direction_is_top
		from
			bet
		where
			(details->>'subtype')::bet_subtype = 'team_position'
			and bet_type = 'main_event';
			
	create temp table if not exists temp_score_bets as
		select
			id,
			status,
			(details->>'teamId')::int8 as team_id,
			(details->>'eventId')::int8 as event_id,
			(details->>'ouValue')::float as ou_value,
			(details->>'directionIsOver')::boolean as direction_is_over
		from
			bet
		where
			bet_type = 'main_event' and
			(details->>'subtype')::bet_subtype = 'score';

	for event_team in 
		select * from temp_team_scores
	loop
		insert into event_team_round_score (team_id, round_number, score) 
		  values (event_team.team_id, 1, event_team.score)
		  on conflict on constraint
			/* Added for debugging. In practice, a round should only be submitted once
			   so as to not generate extra transactions */
			team_round_pair
			  do update set score = excluded.score;

		for bet_row in
			select * from temp_team_position_bets
			where team_id = event_team.team_id
		loop
			if bet_row.status != 'active' then
				continue; 
			end if;
			if bet_row.direction_is_top then
				if event_team.position <= bet_row.number_of_teams then
					perform submit_bet_requester_won(bet_row.id);
				else
					perform submit_bet_opponent_won(bet_row.id);
				end if;
				continue;
			end if;
			
			if not bet_row.direction_is_top then
				select 1+count(team_id) into position_from_bottom
				from temp_team_scores
				where position > event_team.position;
				
				if position_from_bottom <= bet_row.number_of_teams then
					perform submit_bet_requester_won(bet_row.id);
				else
					perform submit_bet_opponent_won(bet_row.id);
				end if;		
			end if;
		end loop;
		
		for bet_row in
			select * from temp_score_bets
			where team_id = event_team.team_id
		loop
			if bet_row.status != 'active' then
				continue;
			end if;
			
			if bet_row.ou_value = event_team.score then
				perform submit_bet_push(bet_row.id);
				continue;
			end if;
			if (bet_row.direction_is_over and event_team.score > bet_row.ou_value)
				or ((not bet_row.direction_is_over) and event_team.score < bet_row.ou_value) then
				perform submit_bet_requester_won(bet_row.id);
				continue;
			end if;
			perform submit_bet_opponent_won(bet_row.id);
		end loop;
	end loop;

	update game_state
	set round_phase = 'waiting_for_next_round'
	where id = 1;
END;$function$
;

CREATE OR REPLACE FUNCTION public.submit_space_event_player_score_changes(space_event_id bigint, space_event_template_id bigint, player_score_changes json, event_description text, is_chaos_space_event boolean, add_lost_points_to_bank_balance boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    player_id bigint;
    points bigint;
    round_num smallint;
    display_name_of_player_who_landed_on_space text;
    space_name text;
    v_session_id bigint;
BEGIN
    IF is_chaos_space_event THEN
        SELECT u.display_name, cse.round_number, gs.name
        INTO display_name_of_player_who_landed_on_space, round_num, space_name
        FROM "user" u
        JOIN player p ON u.id = p.user_id
        JOIN chaos_space_event cse ON p.id = cse.player_id
        JOIN gameboard_space gs ON cse.chaos_space_id = gs.id
        WHERE cse.id = space_event_id;
    ELSE
        SELECT u.display_name, sse.round_number, gs.name
        INTO display_name_of_player_who_landed_on_space, round_num, space_name
        FROM "user" u
        JOIN player p ON u.id = p.user_id
        JOIN special_space_event sse ON p.id = sse.player_id
        JOIN gameboard_space gs ON sse.special_space_id = gs.id
        WHERE sse.id = space_event_id;
    END IF;

    -- Add a row in the transaction table for each player in player_score_changes
    FOR player_id, points IN SELECT * FROM json_each_text(player_score_changes) LOOP
        IF points <> 0 THEN
            INSERT INTO transaction (player_id, num_points, description, created_at, updated_at)
            VALUES (player_id, points, display_name_of_player_who_landed_on_space || '''s ' || space_name || ' Space event for turn ' || round_num || ': ' || event_description, now(), now());

            -- add lost points to bank balance
            IF add_lost_points_to_bank_balance AND points < 0 THEN
                v_session_id := (SELECT p.session_id from player p WHERE p.id = player_id);

                UPDATE session
                SET bank_balance = bank_balance - points
                WHERE id = v_session_id;
            END IF;
        END IF;
    END LOOP;

    IF is_chaos_space_event THEN
        -- Set the status of the chaos_space_event to 'finished', and set results to player_score_changes JSON
        UPDATE chaos_space_event
        SET template_id = space_event_template_id, status = 'finished', results = player_score_changes
        WHERE id = space_event_id;
    ELSE
        -- Set the status of the special_space_event to 'finished', and set results to player_score_changes JSON
        UPDATE special_space_event
        SET template_id = space_event_template_id, status = 'finished', results = player_score_changes
        WHERE id = space_event_id;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.submit_special_space_event_score(special_space_event_id bigint, score bigint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    player_id_val bigint;
    session_points_per_game_point_val bigint;
    space_name_val text;
    points_label_plural_val text;
    template_name_val text;
    round_number_val smallint;
BEGIN
    -- Update special_space_event row
    UPDATE public.special_space_event
    SET status = 'finished',
        results = jsonb_build_object('score', score)
    WHERE id = special_space_event_id;

    -- Get player_id from special_space_event
    SELECT player_id, round_number INTO player_id_val, round_number_val
    FROM public.special_space_event
    WHERE id = special_space_event_id;

    -- Get session_points_per_game_point from special_space_event_template
    SELECT sset.details->>'sessionPointsPerGamePoint' INTO session_points_per_game_point_val
    FROM public.special_space_event sse
    JOIN public.special_space_event_template sset ON sse.template_id = sset.id
    WHERE sse.id = special_space_event_id;

    -- Get space_name, points_label_plural, and template_name
    SELECT gs.name, sset.details->>'pointsLabelPlural', sset.name
    INTO space_name_val, points_label_plural_val, template_name_val
    FROM public.special_space_event sse
    JOIN public.gameboard_space gs ON sse.special_space_id = gs.id
    JOIN public.special_space_event_template sset ON sse.template_id = sset.id
    WHERE sse.id = special_space_event_id;

    -- Create transaction for player
    INSERT INTO public.transaction (player_id, num_points, description)
    VALUES (player_id_val, score * session_points_per_game_point_val, 
    space_name_val || ' Space event for turn ' || round_number_val || ': ' || score || ' ' || points_label_plural_val || ' in ' || template_name_val);

END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_user_to_public_user()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_name text;
BEGIN
  v_name := initcap(substring(NEW.email from 1 for position('@' in NEW.email) - 1));

  INSERT INTO public.user (id, display_name, real_name)
  VALUES (NEW.id, v_name, v_name); RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_event_teams(event_team_updates json)
 RETURNS void
 LANGUAGE plpgsql
AS $function$BEGIN
-- Delete event teams that were removed in team editor
DELETE FROM public.event_team
WHERE
  id IN (
    SELECT
      (removed_team_json ->> 'id')::BIGINT AS id
    FROM
      JSON_ARRAY_ELEMENTS(event_team_updates::json -> 'removedTeams') AS removed_team_json
  );

-- Insert new event teams
INSERT INTO
  public.event_team (event_id, seed)
SELECT
  (new_event_team_json ->> 'event_id')::BIGINT AS event_id,
  (new_event_team_json ->> 'seed')::SMALLINT AS seed
FROM
  JSON_ARRAY_ELEMENTS(event_team_updates -> 'newEventTeams') AS new_event_team_json;

WITH
-- Get new teams from json
original_team AS (
  SELECT
  (new_event_team_json ->> 'id')::BIGINT AS old_id,
  (new_event_team_json ->> 'event_id')::BIGINT AS event_id,
  (new_event_team_json ->> 'seed')::BIGINT AS seed
FROM
  JSON_ARRAY_ELEMENTS(event_team_updates -> 'newEventTeams') AS new_event_team_json
),
-- Create a mapping of new teams' json id to the id generated on insert
old_id_to_new_id AS (
SELECT
old_id, id
FROM (
    original_team o
  INNER JOIN public.event_team e
  ON o.event_id = e.event_id AND o.seed = e.seed
)
),
-- Get updated participants from json
updated_participant AS (
SELECT
  (updated_participant_json ->> 'id')::BIGINT AS id,
  (updated_participant_json ->> 'team_id')::BIGINT AS team_id
FROM
  JSON_ARRAY_ELEMENTS(event_team_updates -> 'updatedParticipants') AS updated_participant_json
)
-- Update existing participants with their new team id
UPDATE public.event_participant ep
SET
  team_id = updated_participant_with_team_id.team_id
FROM
  (
    SELECT
      elem.id,
      elem.team_id
    FROM
      (
        -- If the participant is on a newly-created team, use the auto-generated id of the new team.  Otherwise, use the id provided in the json
        (
          SELECT
            up.id,
            otn.id AS team_id
          FROM
            updated_participant up
            INNER JOIN old_id_to_new_id otn ON up.team_id = otn.old_id
        )
        UNION
        (
          SELECT
            up.id,
            up.team_id
          FROM
            updated_participant up
          WHERE
            up.team_id NOT IN (
              SELECT
                ot.old_id
              FROM
                original_team ot
            )
        )
      ) AS elem
  ) AS updated_participant_with_team_id
WHERE
  updated_participant_with_team_id.id = ep.id;

WITH
-- Get new teams from json
original_team AS (
  SELECT
  (new_event_team_json ->> 'id')::BIGINT AS old_id,
  (new_event_team_json ->> 'event_id')::BIGINT AS event_id,
  (new_event_team_json ->> 'seed')::BIGINT AS seed
FROM
  JSON_ARRAY_ELEMENTS(event_team_updates -> 'newEventTeams') AS new_event_team_json
),
-- Create a mapping of new teams' json id to the id generated on insert
old_id_to_new_id AS (
SELECT
old_id, id
FROM (
    original_team o
  INNER JOIN public.event_team e
  ON o.event_id = e.event_id AND o.seed = e.seed
)
),
-- Get new participants from json
new_participant AS (
SELECT
  (new_participant_json ->> 'player_id')::BIGINT AS player_id,
  (new_participant_json ->> 'team_id')::BIGINT AS team_id
FROM
  JSON_ARRAY_ELEMENTS(event_team_updates -> 'newParticipants') AS new_participant_json
)

-- Insert new participants
INSERT INTO
  public.event_participant (player_id, team_id)
SELECT
  elem.player_id,
  elem.team_id
FROM
  (
    -- If the participant is on a newly-created team, use the auto-generated id of the new team.  Otherwise, use the id provided in the json
    (
      SELECT
        np.player_id,
        otn.id AS team_id
      FROM
        new_participant np
        INNER JOIN old_id_to_new_id otn ON np.team_id = otn.old_id
    )
    UNION
    (
      SELECT
        player_id,
        team_id
      FROM
        new_participant
      WHERE
        team_id NOT IN (
          SELECT
            ot.old_id
          FROM
            original_team ot
        )
    )
  ) as elem;
-- Delete event participants that were removed in team editor
DELETE FROM public.event_participant
WHERE
  id IN (
    SELECT
      (removed_participant_json ->> 'id')::BIGINT AS id
    FROM
      JSON_ARRAY_ELEMENTS(event_team_updates::json -> 'removedParticipants') AS removed_participant_json
  );

-- Update event team seeds
UPDATE public.event_team
SET
  seed = updated_team.seed
FROM
  (
    SELECT
      (updated_team_json ->> 'id')::BIGINT AS id,
      (updated_team_json ->> 'seed')::SMALLINT AS seed
    FROM
      JSON_ARRAY_ELEMENTS(event_team_updates::json -> 'updatedTeams') AS updated_team_json
  ) AS updated_team
WHERE
  public.event_team.id = updated_team.id;
END;$function$
;

CREATE OR REPLACE FUNCTION public.update_player_score()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    UPDATE player
    SET score = score + NEW.num_points
    WHERE id = NEW.player_id;
    RETURN NEW;
END;
$function$
;

grant delete on table "public"."bet" to "anon";

grant insert on table "public"."bet" to "anon";

grant references on table "public"."bet" to "anon";

grant select on table "public"."bet" to "anon";

grant trigger on table "public"."bet" to "anon";

grant truncate on table "public"."bet" to "anon";

grant update on table "public"."bet" to "anon";

grant delete on table "public"."bet" to "authenticated";

grant insert on table "public"."bet" to "authenticated";

grant references on table "public"."bet" to "authenticated";

grant select on table "public"."bet" to "authenticated";

grant trigger on table "public"."bet" to "authenticated";

grant truncate on table "public"."bet" to "authenticated";

grant update on table "public"."bet" to "authenticated";

grant delete on table "public"."bet" to "service_role";

grant insert on table "public"."bet" to "service_role";

grant references on table "public"."bet" to "service_role";

grant select on table "public"."bet" to "service_role";

grant trigger on table "public"."bet" to "service_role";

grant truncate on table "public"."bet" to "service_role";

grant update on table "public"."bet" to "service_role";

grant delete on table "public"."bracket" to "anon";

grant insert on table "public"."bracket" to "anon";

grant references on table "public"."bracket" to "anon";

grant select on table "public"."bracket" to "anon";

grant trigger on table "public"."bracket" to "anon";

grant truncate on table "public"."bracket" to "anon";

grant update on table "public"."bracket" to "anon";

grant delete on table "public"."bracket" to "authenticated";

grant insert on table "public"."bracket" to "authenticated";

grant references on table "public"."bracket" to "authenticated";

grant select on table "public"."bracket" to "authenticated";

grant trigger on table "public"."bracket" to "authenticated";

grant truncate on table "public"."bracket" to "authenticated";

grant update on table "public"."bracket" to "authenticated";

grant delete on table "public"."bracket" to "service_role";

grant insert on table "public"."bracket" to "service_role";

grant references on table "public"."bracket" to "service_role";

grant select on table "public"."bracket" to "service_role";

grant trigger on table "public"."bracket" to "service_role";

grant truncate on table "public"."bracket" to "service_role";

grant update on table "public"."bracket" to "service_role";

grant delete on table "public"."chaos_space_event" to "anon";

grant insert on table "public"."chaos_space_event" to "anon";

grant references on table "public"."chaos_space_event" to "anon";

grant select on table "public"."chaos_space_event" to "anon";

grant trigger on table "public"."chaos_space_event" to "anon";

grant truncate on table "public"."chaos_space_event" to "anon";

grant update on table "public"."chaos_space_event" to "anon";

grant delete on table "public"."chaos_space_event" to "authenticated";

grant insert on table "public"."chaos_space_event" to "authenticated";

grant references on table "public"."chaos_space_event" to "authenticated";

grant select on table "public"."chaos_space_event" to "authenticated";

grant trigger on table "public"."chaos_space_event" to "authenticated";

grant truncate on table "public"."chaos_space_event" to "authenticated";

grant update on table "public"."chaos_space_event" to "authenticated";

grant delete on table "public"."chaos_space_event" to "service_role";

grant insert on table "public"."chaos_space_event" to "service_role";

grant references on table "public"."chaos_space_event" to "service_role";

grant select on table "public"."chaos_space_event" to "service_role";

grant trigger on table "public"."chaos_space_event" to "service_role";

grant truncate on table "public"."chaos_space_event" to "service_role";

grant update on table "public"."chaos_space_event" to "service_role";

grant delete on table "public"."chaos_space_event_template" to "anon";

grant insert on table "public"."chaos_space_event_template" to "anon";

grant references on table "public"."chaos_space_event_template" to "anon";

grant select on table "public"."chaos_space_event_template" to "anon";

grant trigger on table "public"."chaos_space_event_template" to "anon";

grant truncate on table "public"."chaos_space_event_template" to "anon";

grant update on table "public"."chaos_space_event_template" to "anon";

grant delete on table "public"."chaos_space_event_template" to "authenticated";

grant insert on table "public"."chaos_space_event_template" to "authenticated";

grant references on table "public"."chaos_space_event_template" to "authenticated";

grant select on table "public"."chaos_space_event_template" to "authenticated";

grant trigger on table "public"."chaos_space_event_template" to "authenticated";

grant truncate on table "public"."chaos_space_event_template" to "authenticated";

grant update on table "public"."chaos_space_event_template" to "authenticated";

grant delete on table "public"."chaos_space_event_template" to "service_role";

grant insert on table "public"."chaos_space_event_template" to "service_role";

grant references on table "public"."chaos_space_event_template" to "service_role";

grant select on table "public"."chaos_space_event_template" to "service_role";

grant trigger on table "public"."chaos_space_event_template" to "service_role";

grant truncate on table "public"."chaos_space_event_template" to "service_role";

grant update on table "public"."chaos_space_event_template" to "service_role";

grant delete on table "public"."duel" to "anon";

grant insert on table "public"."duel" to "anon";

grant references on table "public"."duel" to "anon";

grant select on table "public"."duel" to "anon";

grant trigger on table "public"."duel" to "anon";

grant truncate on table "public"."duel" to "anon";

grant update on table "public"."duel" to "anon";

grant delete on table "public"."duel" to "authenticated";

grant insert on table "public"."duel" to "authenticated";

grant references on table "public"."duel" to "authenticated";

grant select on table "public"."duel" to "authenticated";

grant trigger on table "public"."duel" to "authenticated";

grant truncate on table "public"."duel" to "authenticated";

grant update on table "public"."duel" to "authenticated";

grant delete on table "public"."duel" to "service_role";

grant insert on table "public"."duel" to "service_role";

grant references on table "public"."duel" to "service_role";

grant select on table "public"."duel" to "service_role";

grant trigger on table "public"."duel" to "service_role";

grant truncate on table "public"."duel" to "service_role";

grant update on table "public"."duel" to "service_role";

grant delete on table "public"."event" to "anon";

grant insert on table "public"."event" to "anon";

grant references on table "public"."event" to "anon";

grant select on table "public"."event" to "anon";

grant trigger on table "public"."event" to "anon";

grant truncate on table "public"."event" to "anon";

grant update on table "public"."event" to "anon";

grant delete on table "public"."event" to "authenticated";

grant insert on table "public"."event" to "authenticated";

grant references on table "public"."event" to "authenticated";

grant select on table "public"."event" to "authenticated";

grant trigger on table "public"."event" to "authenticated";

grant truncate on table "public"."event" to "authenticated";

grant update on table "public"."event" to "authenticated";

grant delete on table "public"."event" to "service_role";

grant insert on table "public"."event" to "service_role";

grant references on table "public"."event" to "service_role";

grant select on table "public"."event" to "service_role";

grant trigger on table "public"."event" to "service_role";

grant truncate on table "public"."event" to "service_role";

grant update on table "public"."event" to "service_role";

grant delete on table "public"."event_format_standard_scoring_formula" to "anon";

grant insert on table "public"."event_format_standard_scoring_formula" to "anon";

grant references on table "public"."event_format_standard_scoring_formula" to "anon";

grant select on table "public"."event_format_standard_scoring_formula" to "anon";

grant trigger on table "public"."event_format_standard_scoring_formula" to "anon";

grant truncate on table "public"."event_format_standard_scoring_formula" to "anon";

grant update on table "public"."event_format_standard_scoring_formula" to "anon";

grant delete on table "public"."event_format_standard_scoring_formula" to "authenticated";

grant insert on table "public"."event_format_standard_scoring_formula" to "authenticated";

grant references on table "public"."event_format_standard_scoring_formula" to "authenticated";

grant select on table "public"."event_format_standard_scoring_formula" to "authenticated";

grant trigger on table "public"."event_format_standard_scoring_formula" to "authenticated";

grant truncate on table "public"."event_format_standard_scoring_formula" to "authenticated";

grant update on table "public"."event_format_standard_scoring_formula" to "authenticated";

grant delete on table "public"."event_format_standard_scoring_formula" to "service_role";

grant insert on table "public"."event_format_standard_scoring_formula" to "service_role";

grant references on table "public"."event_format_standard_scoring_formula" to "service_role";

grant select on table "public"."event_format_standard_scoring_formula" to "service_role";

grant trigger on table "public"."event_format_standard_scoring_formula" to "service_role";

grant truncate on table "public"."event_format_standard_scoring_formula" to "service_role";

grant update on table "public"."event_format_standard_scoring_formula" to "service_role";

grant delete on table "public"."event_participant" to "anon";

grant insert on table "public"."event_participant" to "anon";

grant references on table "public"."event_participant" to "anon";

grant select on table "public"."event_participant" to "anon";

grant trigger on table "public"."event_participant" to "anon";

grant truncate on table "public"."event_participant" to "anon";

grant update on table "public"."event_participant" to "anon";

grant delete on table "public"."event_participant" to "authenticated";

grant insert on table "public"."event_participant" to "authenticated";

grant references on table "public"."event_participant" to "authenticated";

grant select on table "public"."event_participant" to "authenticated";

grant trigger on table "public"."event_participant" to "authenticated";

grant truncate on table "public"."event_participant" to "authenticated";

grant update on table "public"."event_participant" to "authenticated";

grant delete on table "public"."event_participant" to "service_role";

grant insert on table "public"."event_participant" to "service_role";

grant references on table "public"."event_participant" to "service_role";

grant select on table "public"."event_participant" to "service_role";

grant trigger on table "public"."event_participant" to "service_role";

grant truncate on table "public"."event_participant" to "service_role";

grant update on table "public"."event_participant" to "service_role";

grant delete on table "public"."event_team" to "anon";

grant insert on table "public"."event_team" to "anon";

grant references on table "public"."event_team" to "anon";

grant select on table "public"."event_team" to "anon";

grant trigger on table "public"."event_team" to "anon";

grant truncate on table "public"."event_team" to "anon";

grant update on table "public"."event_team" to "anon";

grant delete on table "public"."event_team" to "authenticated";

grant insert on table "public"."event_team" to "authenticated";

grant references on table "public"."event_team" to "authenticated";

grant select on table "public"."event_team" to "authenticated";

grant trigger on table "public"."event_team" to "authenticated";

grant truncate on table "public"."event_team" to "authenticated";

grant update on table "public"."event_team" to "authenticated";

grant delete on table "public"."event_team" to "service_role";

grant insert on table "public"."event_team" to "service_role";

grant references on table "public"."event_team" to "service_role";

grant select on table "public"."event_team" to "service_role";

grant trigger on table "public"."event_team" to "service_role";

grant truncate on table "public"."event_team" to "service_role";

grant update on table "public"."event_team" to "service_role";

grant delete on table "public"."event_team_round_score" to "anon";

grant insert on table "public"."event_team_round_score" to "anon";

grant references on table "public"."event_team_round_score" to "anon";

grant select on table "public"."event_team_round_score" to "anon";

grant trigger on table "public"."event_team_round_score" to "anon";

grant truncate on table "public"."event_team_round_score" to "anon";

grant update on table "public"."event_team_round_score" to "anon";

grant delete on table "public"."event_team_round_score" to "authenticated";

grant insert on table "public"."event_team_round_score" to "authenticated";

grant references on table "public"."event_team_round_score" to "authenticated";

grant select on table "public"."event_team_round_score" to "authenticated";

grant trigger on table "public"."event_team_round_score" to "authenticated";

grant truncate on table "public"."event_team_round_score" to "authenticated";

grant update on table "public"."event_team_round_score" to "authenticated";

grant delete on table "public"."event_team_round_score" to "service_role";

grant insert on table "public"."event_team_round_score" to "service_role";

grant references on table "public"."event_team_round_score" to "service_role";

grant select on table "public"."event_team_round_score" to "service_role";

grant trigger on table "public"."event_team_round_score" to "service_role";

grant truncate on table "public"."event_team_round_score" to "service_role";

grant update on table "public"."event_team_round_score" to "service_role";

grant delete on table "public"."game_state" to "anon";

grant insert on table "public"."game_state" to "anon";

grant references on table "public"."game_state" to "anon";

grant select on table "public"."game_state" to "anon";

grant trigger on table "public"."game_state" to "anon";

grant truncate on table "public"."game_state" to "anon";

grant update on table "public"."game_state" to "anon";

grant delete on table "public"."game_state" to "authenticated";

grant insert on table "public"."game_state" to "authenticated";

grant references on table "public"."game_state" to "authenticated";

grant select on table "public"."game_state" to "authenticated";

grant trigger on table "public"."game_state" to "authenticated";

grant truncate on table "public"."game_state" to "authenticated";

grant update on table "public"."game_state" to "authenticated";

grant delete on table "public"."game_state" to "service_role";

grant insert on table "public"."game_state" to "service_role";

grant references on table "public"."game_state" to "service_role";

grant select on table "public"."game_state" to "service_role";

grant trigger on table "public"."game_state" to "service_role";

grant truncate on table "public"."game_state" to "service_role";

grant update on table "public"."game_state" to "service_role";

grant delete on table "public"."gameboard_move" to "anon";

grant insert on table "public"."gameboard_move" to "anon";

grant references on table "public"."gameboard_move" to "anon";

grant select on table "public"."gameboard_move" to "anon";

grant trigger on table "public"."gameboard_move" to "anon";

grant truncate on table "public"."gameboard_move" to "anon";

grant update on table "public"."gameboard_move" to "anon";

grant delete on table "public"."gameboard_move" to "authenticated";

grant insert on table "public"."gameboard_move" to "authenticated";

grant references on table "public"."gameboard_move" to "authenticated";

grant select on table "public"."gameboard_move" to "authenticated";

grant trigger on table "public"."gameboard_move" to "authenticated";

grant truncate on table "public"."gameboard_move" to "authenticated";

grant update on table "public"."gameboard_move" to "authenticated";

grant delete on table "public"."gameboard_move" to "service_role";

grant insert on table "public"."gameboard_move" to "service_role";

grant references on table "public"."gameboard_move" to "service_role";

grant select on table "public"."gameboard_move" to "service_role";

grant trigger on table "public"."gameboard_move" to "service_role";

grant truncate on table "public"."gameboard_move" to "service_role";

grant update on table "public"."gameboard_move" to "service_role";

grant delete on table "public"."gameboard_space" to "anon";

grant insert on table "public"."gameboard_space" to "anon";

grant references on table "public"."gameboard_space" to "anon";

grant select on table "public"."gameboard_space" to "anon";

grant trigger on table "public"."gameboard_space" to "anon";

grant truncate on table "public"."gameboard_space" to "anon";

grant update on table "public"."gameboard_space" to "anon";

grant delete on table "public"."gameboard_space" to "authenticated";

grant insert on table "public"."gameboard_space" to "authenticated";

grant references on table "public"."gameboard_space" to "authenticated";

grant select on table "public"."gameboard_space" to "authenticated";

grant trigger on table "public"."gameboard_space" to "authenticated";

grant truncate on table "public"."gameboard_space" to "authenticated";

grant update on table "public"."gameboard_space" to "authenticated";

grant delete on table "public"."gameboard_space" to "service_role";

grant insert on table "public"."gameboard_space" to "service_role";

grant references on table "public"."gameboard_space" to "service_role";

grant select on table "public"."gameboard_space" to "service_role";

grant trigger on table "public"."gameboard_space" to "service_role";

grant truncate on table "public"."gameboard_space" to "service_role";

grant update on table "public"."gameboard_space" to "service_role";

grant delete on table "public"."player" to "anon";

grant insert on table "public"."player" to "anon";

grant references on table "public"."player" to "anon";

grant select on table "public"."player" to "anon";

grant trigger on table "public"."player" to "anon";

grant truncate on table "public"."player" to "anon";

grant update on table "public"."player" to "anon";

grant delete on table "public"."player" to "authenticated";

grant insert on table "public"."player" to "authenticated";

grant references on table "public"."player" to "authenticated";

grant select on table "public"."player" to "authenticated";

grant trigger on table "public"."player" to "authenticated";

grant truncate on table "public"."player" to "authenticated";

grant update on table "public"."player" to "authenticated";

grant delete on table "public"."player" to "service_role";

grant insert on table "public"."player" to "service_role";

grant references on table "public"."player" to "service_role";

grant select on table "public"."player" to "service_role";

grant trigger on table "public"."player" to "service_role";

grant truncate on table "public"."player" to "service_role";

grant update on table "public"."player" to "service_role";

grant delete on table "public"."player_round_score" to "anon";

grant insert on table "public"."player_round_score" to "anon";

grant references on table "public"."player_round_score" to "anon";

grant select on table "public"."player_round_score" to "anon";

grant trigger on table "public"."player_round_score" to "anon";

grant truncate on table "public"."player_round_score" to "anon";

grant update on table "public"."player_round_score" to "anon";

grant delete on table "public"."player_round_score" to "authenticated";

grant insert on table "public"."player_round_score" to "authenticated";

grant references on table "public"."player_round_score" to "authenticated";

grant select on table "public"."player_round_score" to "authenticated";

grant trigger on table "public"."player_round_score" to "authenticated";

grant truncate on table "public"."player_round_score" to "authenticated";

grant update on table "public"."player_round_score" to "authenticated";

grant delete on table "public"."player_round_score" to "service_role";

grant insert on table "public"."player_round_score" to "service_role";

grant references on table "public"."player_round_score" to "service_role";

grant select on table "public"."player_round_score" to "service_role";

grant trigger on table "public"."player_round_score" to "service_role";

grant truncate on table "public"."player_round_score" to "service_role";

grant update on table "public"."player_round_score" to "service_role";

grant delete on table "public"."rules" to "anon";

grant insert on table "public"."rules" to "anon";

grant references on table "public"."rules" to "anon";

grant select on table "public"."rules" to "anon";

grant trigger on table "public"."rules" to "anon";

grant truncate on table "public"."rules" to "anon";

grant update on table "public"."rules" to "anon";

grant delete on table "public"."rules" to "authenticated";

grant insert on table "public"."rules" to "authenticated";

grant references on table "public"."rules" to "authenticated";

grant select on table "public"."rules" to "authenticated";

grant trigger on table "public"."rules" to "authenticated";

grant truncate on table "public"."rules" to "authenticated";

grant update on table "public"."rules" to "authenticated";

grant delete on table "public"."rules" to "service_role";

grant insert on table "public"."rules" to "service_role";

grant references on table "public"."rules" to "service_role";

grant select on table "public"."rules" to "service_role";

grant trigger on table "public"."rules" to "service_role";

grant truncate on table "public"."rules" to "service_role";

grant update on table "public"."rules" to "service_role";

grant delete on table "public"."session" to "anon";

grant insert on table "public"."session" to "anon";

grant references on table "public"."session" to "anon";

grant select on table "public"."session" to "anon";

grant trigger on table "public"."session" to "anon";

grant truncate on table "public"."session" to "anon";

grant update on table "public"."session" to "anon";

grant delete on table "public"."session" to "authenticated";

grant insert on table "public"."session" to "authenticated";

grant references on table "public"."session" to "authenticated";

grant select on table "public"."session" to "authenticated";

grant trigger on table "public"."session" to "authenticated";

grant truncate on table "public"."session" to "authenticated";

grant update on table "public"."session" to "authenticated";

grant delete on table "public"."session" to "service_role";

grant insert on table "public"."session" to "service_role";

grant references on table "public"."session" to "service_role";

grant select on table "public"."session" to "service_role";

grant trigger on table "public"."session" to "service_role";

grant truncate on table "public"."session" to "service_role";

grant update on table "public"."session" to "service_role";

grant delete on table "public"."special_space_event" to "anon";

grant insert on table "public"."special_space_event" to "anon";

grant references on table "public"."special_space_event" to "anon";

grant select on table "public"."special_space_event" to "anon";

grant trigger on table "public"."special_space_event" to "anon";

grant truncate on table "public"."special_space_event" to "anon";

grant update on table "public"."special_space_event" to "anon";

grant delete on table "public"."special_space_event" to "authenticated";

grant insert on table "public"."special_space_event" to "authenticated";

grant references on table "public"."special_space_event" to "authenticated";

grant select on table "public"."special_space_event" to "authenticated";

grant trigger on table "public"."special_space_event" to "authenticated";

grant truncate on table "public"."special_space_event" to "authenticated";

grant update on table "public"."special_space_event" to "authenticated";

grant delete on table "public"."special_space_event" to "service_role";

grant insert on table "public"."special_space_event" to "service_role";

grant references on table "public"."special_space_event" to "service_role";

grant select on table "public"."special_space_event" to "service_role";

grant trigger on table "public"."special_space_event" to "service_role";

grant truncate on table "public"."special_space_event" to "service_role";

grant update on table "public"."special_space_event" to "service_role";

grant delete on table "public"."special_space_event_template" to "anon";

grant insert on table "public"."special_space_event_template" to "anon";

grant references on table "public"."special_space_event_template" to "anon";

grant select on table "public"."special_space_event_template" to "anon";

grant trigger on table "public"."special_space_event_template" to "anon";

grant truncate on table "public"."special_space_event_template" to "anon";

grant update on table "public"."special_space_event_template" to "anon";

grant delete on table "public"."special_space_event_template" to "authenticated";

grant insert on table "public"."special_space_event_template" to "authenticated";

grant references on table "public"."special_space_event_template" to "authenticated";

grant select on table "public"."special_space_event_template" to "authenticated";

grant trigger on table "public"."special_space_event_template" to "authenticated";

grant truncate on table "public"."special_space_event_template" to "authenticated";

grant update on table "public"."special_space_event_template" to "authenticated";

grant delete on table "public"."special_space_event_template" to "service_role";

grant insert on table "public"."special_space_event_template" to "service_role";

grant references on table "public"."special_space_event_template" to "service_role";

grant select on table "public"."special_space_event_template" to "service_role";

grant trigger on table "public"."special_space_event_template" to "service_role";

grant truncate on table "public"."special_space_event_template" to "service_role";

grant update on table "public"."special_space_event_template" to "service_role";

grant delete on table "public"."transaction" to "anon";

grant insert on table "public"."transaction" to "anon";

grant references on table "public"."transaction" to "anon";

grant select on table "public"."transaction" to "anon";

grant trigger on table "public"."transaction" to "anon";

grant truncate on table "public"."transaction" to "anon";

grant update on table "public"."transaction" to "anon";

grant delete on table "public"."transaction" to "authenticated";

grant insert on table "public"."transaction" to "authenticated";

grant references on table "public"."transaction" to "authenticated";

grant select on table "public"."transaction" to "authenticated";

grant trigger on table "public"."transaction" to "authenticated";

grant truncate on table "public"."transaction" to "authenticated";

grant update on table "public"."transaction" to "authenticated";

grant delete on table "public"."transaction" to "service_role";

grant insert on table "public"."transaction" to "service_role";

grant references on table "public"."transaction" to "service_role";

grant select on table "public"."transaction" to "service_role";

grant trigger on table "public"."transaction" to "service_role";

grant truncate on table "public"."transaction" to "service_role";

grant update on table "public"."transaction" to "service_role";

grant delete on table "public"."user" to "anon";

grant insert on table "public"."user" to "anon";

grant references on table "public"."user" to "anon";

grant select on table "public"."user" to "anon";

grant trigger on table "public"."user" to "anon";

grant truncate on table "public"."user" to "anon";

grant update on table "public"."user" to "anon";

grant delete on table "public"."user" to "authenticated";

grant insert on table "public"."user" to "authenticated";

grant references on table "public"."user" to "authenticated";

grant select on table "public"."user" to "authenticated";

grant trigger on table "public"."user" to "authenticated";

grant truncate on table "public"."user" to "authenticated";

grant update on table "public"."user" to "authenticated";

grant delete on table "public"."user" to "service_role";

grant insert on table "public"."user" to "service_role";

grant references on table "public"."user" to "service_role";

grant select on table "public"."user" to "service_role";

grant trigger on table "public"."user" to "service_role";

grant truncate on table "public"."user" to "service_role";

grant update on table "public"."user" to "service_role";

grant delete on table "public"."user_notifications_subscription" to "anon";

grant insert on table "public"."user_notifications_subscription" to "anon";

grant references on table "public"."user_notifications_subscription" to "anon";

grant select on table "public"."user_notifications_subscription" to "anon";

grant trigger on table "public"."user_notifications_subscription" to "anon";

grant truncate on table "public"."user_notifications_subscription" to "anon";

grant update on table "public"."user_notifications_subscription" to "anon";

grant delete on table "public"."user_notifications_subscription" to "authenticated";

grant insert on table "public"."user_notifications_subscription" to "authenticated";

grant references on table "public"."user_notifications_subscription" to "authenticated";

grant select on table "public"."user_notifications_subscription" to "authenticated";

grant trigger on table "public"."user_notifications_subscription" to "authenticated";

grant truncate on table "public"."user_notifications_subscription" to "authenticated";

grant update on table "public"."user_notifications_subscription" to "authenticated";

grant delete on table "public"."user_notifications_subscription" to "service_role";

grant insert on table "public"."user_notifications_subscription" to "service_role";

grant references on table "public"."user_notifications_subscription" to "service_role";

grant select on table "public"."user_notifications_subscription" to "service_role";

grant trigger on table "public"."user_notifications_subscription" to "service_role";

grant truncate on table "public"."user_notifications_subscription" to "service_role";

grant update on table "public"."user_notifications_subscription" to "service_role";

create policy "Enable ALL for authenticated users"
on "public"."bet"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."bracket"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."chaos_space_event"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."chaos_space_event_template"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."duel"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."event"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."event_format_standard_scoring_formula"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."event_participant"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."event_team"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."event_team_round_score"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."game_state"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."gameboard_move"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."gameboard_space"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."player"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."player_round_score"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."rules"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."session"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."special_space_event"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."special_space_event_template"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."transaction"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."user"
as permissive
for all
to authenticated
using (true);


create policy "Enable all for authenticated users only"
on "public"."user_notifications_subscription"
as permissive
for all
to authenticated
using (true);


CREATE TRIGGER bet_push_notifications AFTER INSERT OR UPDATE ON public.bet FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://hqomdxggwvkmaovkytld.supabase.co/functions/v1/push', 'POST', '{"Content-type":"application/json","Authorization":"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhxb21keGdnd3ZrbWFvdmt5dGxkIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcwNzM0OTQ0NCwiZXhwIjoyMDIyOTI1NDQ0fQ.T3STqcvwqW8zxtcr-r-5jNOPe0ddp8GsAwKFy4qIMeE"}', '{"poop":"butt"}', '1000');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.bet FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.bracket FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.chaos_space_event FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER resolve_chaos_event_bets AFTER UPDATE ON public.chaos_space_event FOR EACH ROW EXECUTE FUNCTION resolve_chaos_event_bets();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.chaos_space_event_template FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.duel FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER resolve_duel_bets_trigger AFTER UPDATE ON public.duel FOR EACH ROW EXECUTE FUNCTION resolve_duel_bets();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.event FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER set_new_event_round_number_trigger BEFORE INSERT ON public.event FOR EACH ROW EXECUTE FUNCTION set_new_event_round_number();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.event_format_standard_scoring_formula FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.event_participant FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.event_team FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.event_team_round_score FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.game_state FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.gameboard_move FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER resolve_gameboard_move_bets AFTER INSERT ON public.gameboard_move FOR EACH ROW EXECUTE FUNCTION resolve_gameboard_move_bets();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.gameboard_space FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.player FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.player_round_score FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.rules FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.session FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.special_space_event FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER resolve_ss_event_bets AFTER UPDATE ON public.special_space_event FOR EACH ROW EXECUTE FUNCTION resolve_ss_event_bets();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.special_space_event_template FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.transaction FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER update_player_score_trigger AFTER INSERT ON public.transaction FOR EACH ROW EXECUTE FUNCTION update_player_score();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public."user" FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.user_notifications_subscription FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');


